{"title":"为什么用OkHttp","date":"2021-08-26T08:44:38.000Z","date_formatted":{"ll":"2021年8月26日","L":"2021/08/26","MM-DD":"08-26"},"link":"posts/1629967595","comments":true,"tags":["网络三件套"],"categories":["Android"],"updated":"2021-12-28T14:26:07.606Z","content":"<p>提起Android上常用的网络框架，太多太多，从早前的HttpClient，到被Google认定的HttpUrlConnection，还有万剑齐发的Volley，但是伴隨后来的大Boss——OkHttp的出现，似乎前边的曾经不可一世的网络框架都沉寂了，为什么OkHttp这么牛，牛在哪里呢，本文就着重说一下。</p>\n<a id=\"more\"></a>\n<h2 id=\"过往网络框架特点\">过往网络框架特点<a title=\"#过往网络框架特点\" href=\"#过往网络框架特点\"></a></h2>\n<p><strong>HttpClient</strong>是一个老牌的网络框架，也是Java平台通用的网络框架，apache出品，android早期是支持HttpClient网络框架的，但是由于HttpClient功能复杂Api臃肿，不好维护，这就导致Google开发团队，不得不在Android6.0放弃他，转而扶正更轻量的HttpUrlConnection。</p>\n<p><strong>HttpUrlConnection</strong>是android SDK自带的网络请求框架，很轻量，同时也很基础。为了防止Android主线程阻塞，HttpUrlConnection常常和Thread、Handler联合使用，但是正因为太基础，HttpUrlConnect在真正的实现业务的时候要进行着重封装，稍不留神就很难维护。另外在Android 2.2版本之前, HttpURLConnection一直存在着一些令人厌烦的bug. 比如说对一个可读的InputStream调用close()方法时，就有可能会导致连接池失效了。</p>\n<p><strong>Volley</strong>是google在2013年Google I/O推出来的轻量级网络通信框架，主打轻量，使用与频繁请求多请求且响应比较快的业务场景，这也是我开头说的万剑齐发。使用很简单，但是不适合上传下载这种大量数据的网络操作。工作原理也很简单：</p>\n<ol>\n<li>建立请求队列（RequestQueue），一个场景下的所有请求都加入到队列中。</li>\n<li>接着调度分发，Volley内部有两个调度器，一个是缓存调度器（CacheDispatcher），一个是网络调度器（NetworkDispatcher），一个请求开始判断请求是否支持缓存，支持的话就加到等待队列中进行去重，然后从缓存调度器中取数据（过期判断、缓存判断），取不到再通过网络调度器进行网络请求。</li>\n<li>等待数据返回。</li>\n</ol>\n<p>volley在创建请求队列的时候是默认创建一个缓存调度线程和4个网络调度线程，并且请求过程中根据android版本号9区分使用网络引擎是HttpClient还是HttpUrlConnection。</p>\n<p>以上网络框架使用过程中是不是很头疼呢？有的系统不支持，有的要好好封装、有的呢又无法满足我们的业务需求，处处是坑，处处有风险。那么有没有一个框架能够满足一下特点呢？</p>\n<ol>\n<li>调用简单</li>\n<li>易扩展易配置</li>\n<li>自带子线程</li>\n<li>各种请求场景都包含，请求稳定</li>\n<li>性能优越，支持高并发</li>\n<li>支持缓存</li>\n<li>支持压缩</li>\n<li>支持自动重连</li>\n<li>支持DNS解析处理</li>\n<li>支持http2</li>\n<li>支持业务需求拦截</li>\n</ol>\n<p>他就是我们今天要讲的主角——OkHttp</p>\n<h2 id=\"okhttp简介\">Okhttp简介<a title=\"#okhttp简介\" href=\"#okhttp简介\"></a></h2>\n<p>OkHttp是目前很火的网络请求框架，OkHttp采用<code>Okio</code>代替常规的输入输出流处理，效率更高，而网络传输这块采用<code>Socket</code>，直面网络底层。从Android4.4开始HttpURLConnection的底层就是采用okhttp实现的。</p>\n<p>来自官方的说明：</p>\n<blockquote>\n<p>OkHttp is an HTTP client that’s efficient by default:<br>\nHTTP/2 support allows all requests to the same host to share a socket.<br>\nConnection pooling reduces request latency (if HTTP/2 isn’t available).<br>\nTransparent GZIP shrinks download sizes.<br>\nResponse caching avoids the network completely for repeat requests.</p>\n</blockquote>\n<p>OkHttp支持http2，当然需要你请求的服务端支持才行，针对http1.x，OkHttp采用了连接池降低网络延迟，内部实现gzip透明传输，使用者无需关注，支持http协议上的缓存用于避免重复网络请求。</p>\n<p>更多详看：<a href=\"https://square.github.io/okhttp/\">https://square.github.io/okhttp/</a></p>\n<h2 id=\"okhttp使用方法\">OkHttp使用方法<a title=\"#okhttp使用方法\" href=\"#okhttp使用方法\"></a></h2>\n<h3 id=\"1.添加依赖\">1.添加依赖<a title=\"#1.添加依赖\" href=\"#1.添加依赖\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&#x27;com.squareup.okhttp3:okhttp:3.14.4&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 如果自己不想写日志拦截器，可以采用okhttp封好的日志拦截器（自选，一般是自己封日志拦截器，更灵活）</span></span><br><span class=\"line\">implementation <span class=\"string\">&#x27;com.squareup.okhttp3:logging-interceptor:3.10.0&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2.使用\">2.使用<a title=\"#2.使用\" href=\"#2.使用\"></a></h3>\n<p>依POST方式为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 创建请求体</span></span><br><span class=\"line\">MediaType mediaType = MediaType.parse(<span class=\"string\">&quot;text/x-markdown; charset=utf-8&quot;</span>);</span><br><span class=\"line\">String body = <span class=\"string\">&quot;I am ixinrun&quot;</span>;</span><br><span class=\"line\">RequestBody requestBody = RequestBody.create(mediaType, body);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 构建请求</span></span><br><span class=\"line\">Request request = <span class=\"keyword\">new</span> Request.Builder()</span><br><span class=\"line\">        .url(<span class=\"string\">&quot;https://api.github.com/markdown/raw&quot;</span>)</span><br><span class=\"line\">        .post(requestBody)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 创建OkHttpClient</span></span><br><span class=\"line\">OkHttpClient okHttpClient = <span class=\"keyword\">new</span> OkHttpClient.Builder()</span><br><span class=\"line\">                .connectTimeout(<span class=\"number\">10</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">                .readTimeout(<span class=\"number\">30</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">                .writeTimeout(<span class=\"number\">30</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">                .addInterceptor(<span class=\"keyword\">new</span> LogInterceptor())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\"><span class=\"comment\">// 4. 执行请求（同步或者异步）</span></span><br><span class=\"line\">okHttpClient.newCall(request).enqueue(<span class=\"keyword\">new</span> Callback() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * 连接失败（超时、取消等引起）</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> call</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> e</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call call, IOException e)</span> </span>&#123;</span><br><span class=\"line\">        Log.d(TAG, <span class=\"string\">&quot;onFailure: &quot;</span> + e.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * 连接成功，网络请求有相应，但是不一定是服务器正常返回，也有可能500或者404</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> call</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> response</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@throws</span> IOException</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call call, Response response)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 响应状态、响应提示（一般是错误提示）</span></span><br><span class=\"line\">        Log.d(TAG, response.code() + <span class=\"string\">&quot; &quot;</span> + response.message());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 响应头部</span></span><br><span class=\"line\">        Headers headers = response.headers();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; headers.size(); i++) &#123;</span><br><span class=\"line\">            Log.d(TAG, headers.name(i) + <span class=\"string\">&quot;:&quot;</span> + headers.value(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 响应体</span></span><br><span class=\"line\">        Log.d(TAG, <span class=\"string\">&quot;onResponse: &quot;</span> + response.body().string());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>一个请求过程需要经过4步：</p>\n<ol>\n<li>创建请求体<br>\n针对post请求需要创建一个请求体，get请求可忽略，用于包装参数类型和参数值，请求体可以创建成String串、字节流、Form表单、文件、Multipart复合体。</li>\n<li>构建请求<br>\n构建一个完整的请求，确定请求地址，请求方法、请求参数、请求header等。请求方法也有get、post、put、delete等。</li>\n<li>构建OkHttpClient<br>\n创造一个OkHttpClient引擎，可以配置超时、失败重连、拦截器、DNS、缓存、cookie等选项。</li>\n<li>执行请求<br>\n将上边的请求加入到OkHttpClient请求队列中创建出一个Call（拥有同步执行、异步执行、取消等相关动作），接着执行请求，这里有两种类型，一种是同步类型（execute）另一种是异步类型（enqueue），异步类型可以回调监听网络访问结果，这里需要注意一下，回调的线程并不是UI线程。</li>\n</ol>\n<h3 id=\"3.常见请求体\">3.常见请求体<a title=\"#3.常见请求体\" href=\"#3.常见请求体\"></a></h3>\n<p>以下举例一些POST方式中常见的请求体构建方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串</span></span><br><span class=\"line\">MediaType strMediaType = MediaType.parse(<span class=\"string\">&quot;text/plain; charset=utf-8&quot;</span>);</span><br><span class=\"line\">String body = <span class=\"string\">&quot;I am ixinrun&quot;</span>;</span><br><span class=\"line\">RequestBody strBody = RequestBody.create(strMediaType, body);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 文件</span></span><br><span class=\"line\">MediaType imageType = MediaType.parse(<span class=\"string\">&quot;image/jpg&quot;</span>);</span><br><span class=\"line\">File file = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;123.jpg&quot;</span>);</span><br><span class=\"line\">RequestBody fileBody = RequestBody.create(imageType, file);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Form表单</span></span><br><span class=\"line\">RequestBody formBody = <span class=\"keyword\">new</span> FormBody.Builder()</span><br><span class=\"line\">        .add(<span class=\"string\">&quot;search&quot;</span>, <span class=\"string\">&quot;Jurassic Park&quot;</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Multipart复合体，将多个RequestBody包装在一起，可以构建与HTML文件上传格式兼容的复杂请求体</span></span><br><span class=\"line\">RequestBody multipartBody = <span class=\"keyword\">new</span> MultipartBody.Builder()</span><br><span class=\"line\">        .setType(MultipartBody.FORM)</span><br><span class=\"line\">        .addFormDataPart(<span class=\"string\">&quot;str&quot;</span>, strBody)</span><br><span class=\"line\">        .addFormDataPart(<span class=\"string\">&quot;file&quot;</span>, file.getName(), fileBody)</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n<h2 id=\"okhttp原理分析\">OkHttp原理分析<a title=\"#okhttp原理分析\" href=\"#okhttp原理分析\"></a></h2>\n<ul>\n<li>Dispatcher 调度器</li>\n<li>xxxCalls 执行队列</li>\n<li>RealCall 响应回调</li>\n<li>Interceptor 拦截器</li>\n</ul>\n<h3 id=\"调度器\">调度器<a title=\"#调度器\" href=\"#调度器\"></a></h3>\n<p>每创建一个OkHttpClient对象对应生成一个Dispatcher调度器，调度器主要用于网络并发处理，队列任务分发，和网络请求的执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dispatcher</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxRequests = <span class=\"number\">64</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxRequestsPerHost = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"meta\">@Nullable</span> Runnable idleCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/** Executes calls. Created lazily. */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"meta\">@Nullable</span> ExecutorService executorService;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/** Ready async calls in the order they&#x27;ll be run. */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/** Running asynchronous calls. Includes canceled calls that haven&#x27;t finished yet. */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/** Running synchronous calls. Includes canceled calls that haven&#x27;t finished yet. */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每个调度器默认最大并发数量为64和单个Host最大并发数量是5，这样处理是为了方式服务器压力过大而宕机所做的前端限制，当然这两个数也是可以根据自己服务器进行自定义调整的。</p>\n<h3 id=\"执行队列\">执行队列<a title=\"#执行队列\" href=\"#执行队列\"></a></h3>\n<p>每个调度器还会预先创建三个队列：</p>\n<ol>\n<li>readyAsyncCalls  异步准备队列</li>\n<li>runningAsyncCalls 异步运行队列</li>\n<li>runningSyncCalls 同步请求队列</li>\n</ol>\n<p>然后根据执行方式是异步还是同步加入到相应的队列中进行下一步处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 异步</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(AsyncCall call)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class=\"line\">        runningAsyncCalls.add(call);</span><br><span class=\"line\">        executorService().execute(call);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        readyAsyncCalls.add(call);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">executed</span><span class=\"params\">(RealCall call)</span> </span>&#123;</span><br><span class=\"line\">    runningSyncCalls.add(call);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同时每个调度器在执行请求的时候会优先创建一个单例线程executorService，用于接下来执行AsyncCall内部的网络请求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> ExecutorService <span class=\"title\">executorService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (executorService == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    executorService = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE, <span class=\"number\">60</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class=\"string\">&quot;OkHttp Dispatcher&quot;</span>, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> executorService;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"响应回调\">响应回调<a title=\"#响应回调\" href=\"#响应回调\"></a></h3>\n<p>AsyncCall是RealCall的内部类，用于网络请求处理，底层引擎采用<code>Socket + okio(IO)</code>实现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncCall</span> <span class=\"keyword\">extends</span> <span class=\"title\">NamedRunnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> signalledCallback = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Response response = getResponseWithInterceptorChain();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class=\"line\">        signalledCallback = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        responseCallback.onFailure(RealCall.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> IOException(<span class=\"string\">&quot;Canceled&quot;</span>));</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        signalledCallback = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        responseCallback.onResponse(RealCall.<span class=\"keyword\">this</span>, response);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (signalledCallback) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Do not signal the callback twice!</span></span><br><span class=\"line\">        Platform.get().log(INFO, <span class=\"string\">&quot;Callback failure for &quot;</span> + toLoggableString(), e);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        eventListener.callFailed(RealCall.<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">        responseCallback.onFailure(RealCall.<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      client.dispatcher().finished(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"拦截器\">拦截器<a title=\"#拦截器\" href=\"#拦截器\"></a></h3>\n<p>AsyncCall执行时优先获取Okhttp的所有拦截器，根据拦截器处理应对网络万变，这也是OkHttp的精髓。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Response <span class=\"title\">getResponseWithInterceptorChain</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Build a full stack of interceptors.</span></span><br><span class=\"line\">  List&lt;Interceptor&gt; interceptors = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  interceptors.addAll(client.interceptors());</span><br><span class=\"line\">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class=\"line\">  interceptors.add(<span class=\"keyword\">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class=\"line\">  interceptors.add(<span class=\"keyword\">new</span> CacheInterceptor(client.internalCache()));</span><br><span class=\"line\">  interceptors.add(<span class=\"keyword\">new</span> ConnectInterceptor(client));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!forWebSocket) &#123;</span><br><span class=\"line\">    interceptors.addAll(client.networkInterceptors());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  interceptors.add(<span class=\"keyword\">new</span> CallServerInterceptor(forWebSocket));</span><br><span class=\"line\"></span><br><span class=\"line\">  Interceptor.Chain chain = <span class=\"keyword\">new</span> RealInterceptorChain(interceptors, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">      originalRequest, <span class=\"keyword\">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class=\"line\">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> chain.proceed(originalRequest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/21D8D10204874BA0A85716B0A38A5750?method=download&amp;shareKey=6c38620890f987594740166e4cf84224\" alt=\"OkHttp拦截器图示\" loading=\"lazy\" class=\"φbp\"></p>\n<p>最后通过所有的拦截器，最终获取到我们所需要的网络结果。记着响应回调是在子线程中哦，这也是为什么要用到RxJava的原因了。</p>\n","prev":{"title":"轻松玩转Flutter混合开发","link":"posts/1631175663"},"next":{"title":"常见算法解题思路","link":"posts/1621934400"},"plink":"https://blog.ixin.run/posts/1629967595/","toc":[{"id":"过往网络框架特点","title":"过往网络框架特点","index":"1"},{"id":"okhttp简介","title":"Okhttp简介","index":"2"},{"id":"okhttp使用方法","title":"OkHttp使用方法","index":"3","children":[{"id":"1.添加依赖","title":"1.添加依赖","index":"3.1"},{"id":"2.使用","title":"2.使用","index":"3.2"},{"id":"3.常见请求体","title":"3.常见请求体","index":"3.3"}]},{"id":"okhttp原理分析","title":"OkHttp原理分析","index":"4","children":[{"id":"调度器","title":"调度器","index":"4.1"},{"id":"执行队列","title":"执行队列","index":"4.2"},{"id":"响应回调","title":"响应回调","index":"4.3"},{"id":"拦截器","title":"拦截器","index":"4.4"}]}],"reward":true,"copyright":{"author":"乂星人","link":"<a href=\"https://blog.ixin.run/posts/1629967595/\" title=\"为什么用OkHttp\">https://blog.ixin.run/posts/1629967595/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}