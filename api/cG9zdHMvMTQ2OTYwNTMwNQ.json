{"title":"Android开发Handler消息机制探究","date":"2016-07-27T07:41:45.000Z","date_formatted":{"ll":"2016年7月27日","L":"2016/07/27","MM-DD":"07-27"},"link":"posts/1469605305","comments":true,"tags":["线程间通信"],"categories":["Android"],"updated":"2022-08-25T14:14:20.385Z","content":"<p>我们知道一个应用启动时系统会为其创建一个进程，而每一个Activity启动的时候又会形成一个线程，这个线程叫主线程，又叫UI线程。Android的主线程是不安全的，因为从主线程中可以创建多个子线程来分配任务，一个activity的所有view都是唯一的，都有唯一的标识，如果在每个子线程中更新view，我们不能预知线程执行结果的先后顺序，也就无法预知什么时候才能更新view，所以造成结果就是view更新时的冲突问题。这也就是为什么从安卓2.0之后官方规定只能在主线程中更新界面了，子线程执行结果后通知主线程更新界面的桥梁便需要handler来帮忙，本篇深入探究一下handle的工作机制。</p>\n<a id=\"more\"></a>\n<h2 id=\"handler是什么\">Handler是什么<a title=\"#handler是什么\" href=\"#handler是什么\"></a></h2>\n<p>上边提到Android中子线程执行结果后需要通知主线程去更新界面，中间的桥梁就是handler，一句话说明白handler就是线程之间通信的桥梁。</p>\n<p>Handler重要有两个作用：</p>\n<ul>\n<li>在一个线程中发送消息。</li>\n<li>在另外一个线程中接收消息。</li>\n</ul>\n<h2 id=\"handler的使用\">Handler的使用<a title=\"#handler的使用\" href=\"#handler的使用\"></a></h2>\n<p>Handler类中包含如下方法用于发送和处理消息：</p>\n<ul>\n<li>void handlerMessage(Message msg)：处理消息的方法,该方法通常用于被重写。</li>\n<li>final boolean hasMessage(int what)：检查消息队列中是否包含what属性为指定值的消息。</li>\n<li>final boolean hasMessage(int what,Object object)：检查消息队列中是否包含what属性为指定且object属性为指定指定对象的消息。</li>\n<li>多个重载的obtainMessage()：从消息池中获取消息（消息池中没有则会重新生成一个，也可以用“Message.obtain()”来代替）</li>\n<li>sendEmptyMessage(int what)：发送空消息。</li>\n<li>final boolean sendEmptyMessageDelayed(int what,long delayMillis)：指定多少毫秒之后发送空消息。</li>\n<li>final boolean sendMessage(Message msg)：立即发送消息。</li>\n<li>final boolean sendMessageDelayed(Message msg,long delayMillis)：指定多少毫秒之后发送消息。</li>\n</ul>\n<p><strong>口说无凭，栗子先行</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Handler handler;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        <span class=\"keyword\">new</span> MyThread1().start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> MyThread2().start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\"> </span><br><span class=\"line\">            Looper.prepare();</span><br><span class=\"line\"> </span><br><span class=\"line\">            handler = <span class=\"keyword\">new</span> Handler()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">super</span>.handleMessage(msg);</span><br><span class=\"line\">                    System.out.println( <span class=\"string\">&quot;threadName--&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;messageWhat-&quot;</span>+ msg.what );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">            Looper.loop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread2</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                sleep( <span class=\"number\">4000</span> );</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            handler1.sendEmptyMessage(<span class=\"number\">0</span>) ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>眼尖的同学可能会看到创建Handler对象时上边下边分别来了一个“Looper.prepare()”、“Looper.loop()”，并且这两行去掉后程序直接报异常，但是我们平时在开发过程并没有写这两句也一样运行完好怎么回事呢？接下来通过Handler的工作原理为这些疑惑解开面纱。</p>\n<h2 id=\"handler的工作原理\">Handler的工作原理<a title=\"#handler的工作原理\" href=\"#handler的工作原理\"></a></h2>\n<p>为了更好的理解Handler的工作原理，先介绍一下与Handler一起工作的几个组件。</p>\n<ul>\n<li>Message: Handler接收和处理的消息对象。</li>\n<li>Looper:每个线程只能拥有一个Looper。它的loop方法负责读取MessageQueue中的消息，之后把消息交给发送该消息的Handler处理。</li>\n<li>MessageQueue:消息队列，使用先进先出的方式来管理Message。程序创建Looper对象时会在它的构造器中创建MessageQueue对象。</li>\n</ul>\n<p>Looper构造器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue();</span><br><span class=\"line\">    mRun = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    mThread = Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该构造器使用了private进行修饰，我们平时使用过程中不能直接通过此构造器创建一个实例。这个构造器同时也告诉我们在初始化Looper时会创建一个与之关联的MessageQueue，负责管理消息的存储队列。</p>\n<p>Handler主要作用就是发送消息和处理消息，Handler发送消息必须被送到指定线程的消息队列MessageQueue，所以在Handler创建之前必须要有一个属于该线程的MessageQueue的实例对象，而MessageQueue却是由Looper初始化时进行实例化的，所以在Handler创建之前必须要有一个该线程所属的Looper的存在，这就回归到之前所提的为什么要在Handler创建前后分别进行追加“Looper.prepare()”、“Looper.loop()”的疑惑了。</p>\n<p>整个过程如下：</p>\n<ol>\n<li>Looper先通过ThreadLocal进行存储，一个线程只能有一个Looper。</li>\n<li>Handler构造函数中通过<code>Looper.myLooper</code>获取到该Handler所拥有的那个Looper，命令的背后是<code>ThreadLocal.get</code>。</li>\n<li>每一个Looper初始化的时候创建一个MessageQueue，用于消息的存储和遍历。</li>\n<li>Handler在sendMessag的时候往MessageQueue里面存储消息。</li>\n<li><code>Looper.looper()</code>是把存储在MessageQueue里面的消息进行逐个遍历，并进行分发。</li>\n</ol>\n<h3 id=\"looper.prepare()\">Looper.prepare()<a title=\"#looper.prepare()\" href=\"#looper.prepare()\"></a></h3>\n<p>线程中创建Handler对象必须要先创建一个Looper，而我们自主创建Looper对象直接调用它的prepare()方法即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>prepare方法还有一个作用就是保证每个线程只有一个Looper对象，其原理就是从ThreadLocal中判断当前线程是否已经存在了一个Looper，如果有则抛出异常，告诉你Looper有了不用再创建了。针对ThreadLocal的认识，我后边也会重点研究一下。</p>\n<p>Android的UI更新必须在主线程。主UI线程中系统已经初始化了一个Looper对象，因此在主线程中直接new一个Handler对象即可，如果我们希望在子线程中创建Handler对象来更新UI，则需要传入主线程Looper：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Handler mainHandler = <span class=\"keyword\">new</span> Handler(Looper.getMainLooper());</span><br><span class=\"line\">mainHandler.post(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//在主线程中更新UI</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"消息的发送\">消息的发送<a title=\"#消息的发送\" href=\"#消息的发送\"></a></h3>\n<p>消息的发送是由Handler处理的，并且发送消息的形式有多样，但是最终都会走到一个<code>sendMessageAtTime</code>这个方法内：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    MessageQueue queue = mQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>handler在发送message的时候首先要找到handler所引用的消息队列，然后才把消息排在消息队列里。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(MessageQueue queue, Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    msg.target = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>准备存入消息队列的消息首先要先设定一个target，并且指向该handler自己，目的就是为了在处理消息环节中，Message能找到正确的Handler，以便准确的被抽取和向下分发。</p>\n<h3 id=\"looper.loop()\">Looper.loop()<a title=\"#looper.loop()\" href=\"#looper.loop()\"></a></h3>\n<p>“Looper.prepare()”是创建消息管理器和消息队列，而“Looper.loop()”则是对消息的依次抽取和分发。loop()方法使用一个死循环不断抽取MessageQueue中的消息，并将取出的消息分发给该消息对应的Handler进行处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Run the message queue in this thread. Be sure to call</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #quit()&#125; to end the loop.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Make sure the identity of this thread is that of the local process,</span></span><br><span class=\"line\">    <span class=\"comment\">// and keep track of what that identity token actually is.</span></span><br><span class=\"line\">    Binder.clearCallingIdentity();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// might block</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Printer logging = me.mLogging;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            logging.println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class=\"string\">&quot; &quot;</span> +</span><br><span class=\"line\">                    msg.callback + <span class=\"string\">&quot;: &quot;</span> + msg.what);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> traceTag = me.mTraceTag;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class=\"line\">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> start = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> end;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            msg.target.dispatchMessage(msg);</span><br><span class=\"line\">            end = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                Trace.traceEnd(traceTag);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowDispatchThresholdMs &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> time = end - start;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class=\"line\">                Slog.w(TAG, <span class=\"string\">&quot;Dispatch took &quot;</span> + time + <span class=\"string\">&quot;ms on &quot;</span></span><br><span class=\"line\">                        + Thread.currentThread().getName() + <span class=\"string\">&quot;, h=&quot;</span> +</span><br><span class=\"line\">                        msg.target + <span class=\"string\">&quot; cb=&quot;</span> + msg.callback + <span class=\"string\">&quot; msg=&quot;</span> + msg.what);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            logging.println(<span class=\"string\">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class=\"string\">&quot; &quot;</span> + msg.callback);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Make sure that during the course of dispatching the</span></span><br><span class=\"line\">        <span class=\"comment\">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ident != newIdent) &#123;</span><br><span class=\"line\">            Log.wtf(TAG, <span class=\"string\">&quot;Thread identity changed from 0x&quot;</span></span><br><span class=\"line\">                    + Long.toHexString(ident) + <span class=\"string\">&quot; to 0x&quot;</span></span><br><span class=\"line\">                    + Long.toHexString(newIdent) + <span class=\"string\">&quot; while dispatching to &quot;</span></span><br><span class=\"line\">                    + msg.target.getClass().getName() + <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">                    + msg.callback + <span class=\"string\">&quot; what=&quot;</span> + msg.what);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.recycleUnchecked();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：在消息分发过程中，如果是Handler的消息回调在主线程，不建议进行耗时操作，有一种检测卡顿（耗时）的方案就是通过消息分发前后的日志打印时间间隔来判断的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分发前打印日志</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                logging.println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class=\"string\">&quot; &quot;</span> +</span><br><span class=\"line\">                        msg.callback + <span class=\"string\">&quot;: &quot;</span> + msg.what);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 分发后打印日志</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            logging.println(<span class=\"string\">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class=\"string\">&quot; &quot;</span> + msg.callback);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>通过日志标识<code>&gt;&gt;&gt;&gt;&gt; Dispatching to </code>和<code>&lt;&lt;&lt;&lt;&lt; Finished to </code>拦截这两条日志，然后判断两个日志产生的时间差即可。</p>\n<h3 id=\"消息的分发\">消息的分发<a title=\"#消息的分发\" href=\"#消息的分发\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Handle system messages here.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        handleCallback(msg);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这一步也算是最后一步消息即将传递到位，只等回调出来了。</p>\n<p>常见消息回调有三种：</p>\n<ol>\n<li>handler.post(Runnable r); //此callback是附加给msg的，因此这种方式即是消息的发送（空消息，携带一个回调），又是分发，使用比较灵活。</li>\n<li>通过构造函数传入一个callback;</li>\n<li>重写Handler内部的<code>handleMessage</code>;</li>\n</ol>\n<h2 id=\"handler同步屏障\">Handler同步屏障<a title=\"#handler同步屏障\" href=\"#handler同步屏障\"></a></h2>\n<p>正常情况下我们发送消息都是同步消息，即在MessageQueue里排好队，等待Looper一个个取出来发送，现在有个场景，需要有一个消息虽然晚发送，但是想让及时收到，怎么办呢，这就需要消息同步屏障了。</p>\n<p>消息机制的同步屏障，其实就是阻碍同步消息，只让异步消息通过。</p>\n<p>设置异步消息方法有多种：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.Handler构造方法中设置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;...&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper, Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.消息体上设置</span></span><br><span class=\"line\">Message msg = Message.obtain();</span><br><span class=\"line\">msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure>\n<p>开启同步屏障：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> traversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br></pre></td></tr></table></figure>\n<p>移除同步屏障:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mHandler.getLooper().getQueue().removeSyncBarrier(traversalBarrier);</span><br></pre></td></tr></table></figure>\n<h3 id=\"同步屏障原理\">同步屏障原理<a title=\"#同步屏障原理\" href=\"#同步屏障原理\"></a></h3>\n<p>同步屏障消息过滤发生在<code>Looper.looper</code>的<code>Message msg = queue.next()</code>，同步屏障的本质就是屏蔽当前的同步消息，拿到当前最靠前的异步消息，进行分发。</p>\n<p>所以我们看一下<code>next()</code>内部是如何实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.如果nextPollTimeoutMillis=-1，一直阻塞不会超时</span></span><br><span class=\"line\">    <span class=\"comment\">// 2.如果nextPollTimeoutMillis=0，不会阻塞，立即返回</span></span><br><span class=\"line\">    <span class=\"comment\">// 3.如果nextPollTimeoutMillis&gt;0，最长阻塞nextPollTimeoutMillis毫秒（超时）</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Binder.flushPendingCommands();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取系统开机到现在的时间戳</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            Message msg = mMessages;</span><br><span class=\"line\">            <span class=\"comment\">// 取出target==null的消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果target==null，那么它就是屏障，需要循环遍历，</span></span><br><span class=\"line\">            <span class=\"comment\">// 一直往后找到第一个异步消息，即msg.isAsynchronous()为true</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 使用一个do..while循环</span></span><br><span class=\"line\">                <span class=\"comment\">// 轮询消息队列里的消息，这里使用do..while循环的原因</span></span><br><span class=\"line\">                <span class=\"comment\">// 是因为do..while循环中取出的这第一个消息是target==null的消息</span></span><br><span class=\"line\">                <span class=\"comment\">// 这个消息是同步屏障的标志消息</span></span><br><span class=\"line\">                <span class=\"comment\">// 接下去进行遍历循环取出Message.isAsynchronous()为true的消息</span></span><br><span class=\"line\">                <span class=\"comment\">// isAsynchronous()为true就是异步消息</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    prevMsg = msg;</span><br><span class=\"line\">                    msg = msg.next;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果有消息需要处理，先判断时间有没有到，如果没有到的话设置阻塞时间</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 计算出离执行时间还有多久赋值给nextPollTimeoutMillis</span></span><br><span class=\"line\">                    <span class=\"comment\">// 表示nativePollOnce方法要等待nextPollTimeoutMillis时长后返回</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 获取到消息</span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 链表操作，获取msg并且删除该节点</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        prevMsg.next = msg.next;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        mMessages = msg.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;Returning message: &quot;</span> + msg);</span><br><span class=\"line\">                    msg.markInUse();</span><br><span class=\"line\">                    <span class=\"comment\">// 返回拿到的消息</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没有消息，nextPollTimeoutMillis复位</span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面next方法可以看出，当消息队列开启同步屏障的时候（即标识为msg.target==null），消息机制在处理消息的时候，会优先处理异步消息。这样，同步屏障就起到了一种过滤和优先级的作用。</p>\n<p>我们知道在<code>handler.sendMessage</code>的时候msg.target优先指向的是Handler自己，那么msg.target==null是什么时候设置的呢？我们不妨去看一下MessageQueue#postSyncBarrier开启同步屏障内部现实：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@TestApi</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里传入的时间是从开机到现在的时间戳</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这就是创建的同步屏障的方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Enqueue a new sync barrier token.</span></span><br><span class=\"line\">    <span class=\"comment\">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> token = mNextBarrierToken++;</span><br><span class=\"line\">        <span class=\"comment\">// 从消息池中获取Message</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Message msg = Message.obtain();</span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        <span class=\"comment\">// 初始化Message对象的时候，并没有给Message.target赋值，</span></span><br><span class=\"line\">        <span class=\"comment\">// 因此Message.target==null</span></span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        msg.arg1 = token;</span><br><span class=\"line\"></span><br><span class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (when != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里的when是要加入的Message的时间</span></span><br><span class=\"line\">            <span class=\"comment\">// 这里遍历是找到Message要加入的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果开启同步屏障的时间（假设记为T）T不为0，且当前的同步消息里有时间小于T，则prev也不为null</span></span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 根据prev是否为null，将msg按照时间顺序插入到消息队列的合适位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>开启消息屏障后，message从消息池中拿出来初始的时候target=null，接下来根据当前系统时间和消息发送时间对比，早于同步屏障这个时间点的消息进行屏障，后边的消息进行放行。</p>\n<ul>\n<li>mMessages指的就是准备发送的消息</li>\n<li>prev指的是同步屏障消息</li>\n<li>while循环操作中，会将mMessages头结点赋值给p变量，将p节点移到当前时刻消息的下一节点</li>\n<li>while循环操作中，p节点的上一节点消息为当前时刻过去时刻的消息，此时！咱们的同步屏障消息msg，就插在这俩者之间！</li>\n</ul>\n<h3 id=\"同步屏障的实际使用场景\">同步屏障的实际使用场景<a title=\"#同步屏障的实际使用场景\" href=\"#同步屏障的实际使用场景\"></a></h3>\n<h2 id=\"注意\">注意<a title=\"#注意\" href=\"#注意\"></a></h2>\n<p>平时使用Handler过程中，我们要格外注意性能和内存泄漏问题。</p>\n<ol>\n<li>\n<p>消息发送有可能是很频繁的，每发送一条消息，我们就要创建一个Message对象，如果发送过快势必会不断的创建新对象导致内存消耗问题。所以我们平时创建对象一般不采用new的形式，而是从消息池中取出来一个“存在”的，有两种方式：</p>\n<ul>\n<li>Message msg = handler.obtainMessage();</li>\n<li>Message msg = Message.obtain();</li>\n</ul>\n</li>\n<li>\n<p>消息发送有可能是缓慢的，此时Handler会持有当前类的引用，这就导致内存无法及时回收进而内存泄漏。针对这个问题要三个手段进行配合最好：<br>\na. Handler定义采用静态内部类的形式定义，脱离类引用的束缚。<br>\nb. Handler内部引用当前类时采用弱引用形式引用，以便于及时回收。<br>\nc. 当前类销毁时取消一切Handler的消息发送。</p>\n</li>\n</ol>\n<p>以上是我对Handler的认识，不准确之处望各位同学指出。</p>\n","prev":{"title":"什么是进程，什么是线程","link":"posts/1469682219"},"next":{"title":"JAVA设计模式之代理模式","link":"posts/1465978376"},"plink":"https://blog.ixin.run/posts/1469605305/","toc":[{"id":"handler是什么","title":"Handler是什么","index":"1"},{"id":"handler的使用","title":"Handler的使用","index":"2"},{"id":"handler的工作原理","title":"Handler的工作原理","index":"3","children":[{"id":"looper.prepare()","title":"Looper.prepare()","index":"3.1"},{"id":"消息的发送","title":"消息的发送","index":"3.2"},{"id":"looper.loop()","title":"Looper.loop()","index":"3.3"},{"id":"消息的分发","title":"消息的分发","index":"3.4"}]},{"id":"handler同步屏障","title":"Handler同步屏障","index":"4","children":[{"id":"同步屏障原理","title":"同步屏障原理","index":"4.1"},{"id":"同步屏障的实际使用场景","title":"同步屏障的实际使用场景","index":"4.2"}]},{"id":"注意","title":"注意","index":"5"}],"reward":true,"copyright":{"author":"乂星人","link":"<a href=\"https://blog.ixin.run/posts/1469605305/\" title=\"Android开发Handler消息机制探究\">https://blog.ixin.run/posts/1469605305/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}