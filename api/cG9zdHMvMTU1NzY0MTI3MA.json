{"title":"Java并发编程（三）ThreadLocal探讨","date":"2019-05-12T06:07:50.000Z","date_formatted":{"ll":"2019年5月12日","L":"2019/05/12","MM-DD":"05-12"},"link":"posts/1557641270","comments":true,"categories":["Java"],"updated":"2022-08-25T14:14:20.389Z","content":"<p>ThreadLocal这部分内容在正常开发过程中可能用的很少，但是却是线程操作不可缺少的，尤其是在线程间通过Handler通信是重要的一环，这一篇我就帮着大家一起分析一下ThreadLocal的使用和内部原理。</p>\n<a id=\"more\"></a>\n<h2 id=\"threadlocal是什么\">ThreadLocal是什么<a title=\"#threadlocal是什么\" href=\"#threadlocal是什么\"></a></h2>\n<p>ThreadLocal 是一个关于创建线程局部变量的类。ThreadLocal 可以把一个对象保存在指定的线程中，对象保存后，只能在指定线程中获取保存的数据，对于其他线程来说则无法获取到数据。</p>\n<h2 id=\"threadlocal使用\">ThreadLocal使用<a title=\"#threadlocal使用\" href=\"#threadlocal使用\"></a></h2>\n<p>ThreadLocal使用非常简单，通常情况下我们只需要关心内部的<code>set()</code>和<code>get()</code>方法即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">&quot;ThreadLocalTest&quot;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> ThreadLocal&lt;String&gt; stringThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 主线程中通过set一个对象</span></span><br><span class=\"line\">        stringThreadLocal.set(<span class=\"string\">&quot;MainThread&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 主线程通过TheadLocal获取该对象, 结果为“MainThread”</span></span><br><span class=\"line\">        Log.d(TAG, <span class=\"string\">&quot;MainThread&#x27;s stringThreadLocal=&quot;</span> + stringThreadLocal.get());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"string\">&quot;Thread#1&quot;</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 子线程中获取该对象，结果为null</span></span><br><span class=\"line\">                Log.d(TAG, <span class=\"string\">&quot;Thread#1&#x27;s stringThreadLocal=&quot;</span> + stringThreadLocal.get());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ThreadLocal也可以设置一个默认值，在获取的时候如果有set值就会取set值，没有就取默认值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ThreadLocal&lt;Boolean&gt; booleanThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;Boolean&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Boolean <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>ThreadLocal还有一个<code>remove</code>，移除保存的对象。</p>\n<h2 id=\"handler中looper和threadlocal的关系\">Handler中Looper和ThreadLocal的关系<a title=\"#handler中looper和threadlocal的关系\" href=\"#handler中looper和threadlocal的关系\"></a></h2>\n<p>我们知道在子线程中使用Handler构建消息体Looper必不可少：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// 准备消息循环体</span></span><br><span class=\"line\">            Looper.prepare();</span><br><span class=\"line\">            <span class=\"comment\">// 构建Handler实例</span></span><br><span class=\"line\">            handler = <span class=\"keyword\">new</span> Handler()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">super</span>.handleMessage(msg);</span><br><span class=\"line\">                    System.out.println( <span class=\"string\">&quot;threadName--&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;messageWhat-&quot;</span>+ msg.what );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"comment\">// 执行looper循环</span></span><br><span class=\"line\">            Looper.loop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在Looper内部定义了一个静态的ThreadLocal，在prepare()过程中专门用来存储Looper实例，并保证一个线程只能有一个Looper实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sThreadLocal.get() will return null unless you&#x27;ve called prepare().</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来在Handler初始化的时候通过<code>ThreadLocal.get</code>获取到该Looper，拿到Looper的MessageQueue，接着Handler可以执行sendMessage，消息就存储在MessageQueue里面。</p>\n<p>最后<code>Looper.looper()</code>的背后执行就是把MessageQueue里的消息进行遍历然后分发的。</p>\n<h2 id=\"threadlocal原理剖析\">ThreadLocal原理剖析<a title=\"#threadlocal原理剖析\" href=\"#threadlocal原理剖析\"></a></h2>\n<p>每一个线程都维护了一个ThreadLocalMap对象，而ThreadLocal存的值就在ThreadLocalMap中（key为ThreadLocal本身，value为当前值），这是是为什么ThreadLocal只能在某个线程中存取其他线程访问不了的原因，一个线程可以拥有多个ThreadLocal（一个线程可以有多个变量存储），但是一个ThreadLocal只能负责一个线程。</p>\n<p>ThreadLocalMap是ThreadLocal的静态内部类，ThreadLocal总共七百多行代码，而ThreadLocalMap就占了四五百行，ThreadLocalMap和ThreadLocal是相互依偎的，将二者结合在一起是设计模式的单一职责原则。</p>\n<p>ThreadLocal 的 public 方法，只有三个：set、get、remove。</p>\n<h3 id=\"set方法\">set方法<a title=\"#set方法\" href=\"#set方法\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>获取当前线程</li>\n<li>得到当前线程所拥有的ThreadLocalMap</li>\n<li>存值，key为当前ThreadLocal本身，value是所有存的对象。</li>\n</ol>\n<p>ThreadLocalMap是如何set呢？来看一下ThreadLocalMap源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Set the value associated with key.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the thread local object</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to be set</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class=\"line\">    <span class=\"comment\">// least as common to use set() to create new entries as</span></span><br><span class=\"line\">    <span class=\"comment\">// it is to replace existing ones, in which case, a fast</span></span><br><span class=\"line\">    <span class=\"comment\">// path would fail more often than not.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            replaceStaleEntry(key, value, i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tab[i] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sz = ++size;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class=\"line\">        rehash();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ThreadLocalMap存值的背后是Entry数组的存值，数组每一个节点即Entry本身作为key（ThreadLocal），弱引用类型，Entry内部维护了一个变量即用来指向ThreadLocal存的那个值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">    Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>数组在存的过程中通过Key（ThreadLocal）的hash作为数组的下标索引i找到目标的Entry，Entry已存在则替换value值，如果不存在，则创建一个新Entry。</p>\n<h3 id=\"entry为什么是弱引用类型\">Entry为什么是弱引用类型<a title=\"#entry为什么是弱引用类型\" href=\"#entry为什么是弱引用类型\"></a></h3>\n<p>如果Entry不是弱引用类型，实质上就会造成节点的生命周期与线程强绑定，只要线程没有销毁，那么节点在GC分析中一直处于可达状态，没办法被回收。</p>\n<p>虽然Entry本身是弱引用，但内部维护的值value是强引用，value引用链不断开则Entry不会回收，一旦value引用链断开了，那么Entry本身也就很容易就回收了。</p>\n<h3 id=\"entry环形数组\">Entry环形数组<a title=\"#entry环形数组\" href=\"#entry环形数组\"></a></h3>\n<p>ThreadLocalMap维护了Entry环形数组，Entry数组的环形结构来自set方法中的<code>nextIndex</code>函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">nextIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ((i + <span class=\"number\">1</span> &lt; len) ? i + <span class=\"number\">1</span> : <span class=\"number\">0</span>);</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>传入index值加一，返回坐标。</li>\n<li>当index值长度超过数组长度后，会直接返回0，又回到了数组头部，完成了环形结构。</li>\n</ol>\n<p>优点就是：</p>\n<ol>\n<li>长度固定，下标永不越界。</li>\n<li>空间利用率高，能够大大的节省内存的开销，能够充分的利用数组的空间。</li>\n</ol>\n<h3 id=\"get方法\">get方法<a title=\"#get方法\" href=\"#get方法\"></a></h3>\n<p>分析完上边的set方法，get方法就简单多了，先看源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (T)e.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>找到当前线程</li>\n<li>找到线程所拥有的ThreadLocalMap</li>\n<li>通过Key（当前的ThreadLocal）找到目标Entry</li>\n<li>Entry的value即为get的值</li>\n</ol>\n<p><code>map.getEntry</code>背后是通过Key（当前的ThreadLocal）的Hash作为Entry数组的某个坐标，找到目标Entry。</p>\n<h3 id=\"remove方法\">remove方法<a title=\"#remove方法\" href=\"#remove方法\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        m.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要看背后<code>ThreadLocalMap.remove</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.get() == key) &#123;</span><br><span class=\"line\">            e.clear();</span><br><span class=\"line\">            expungeStaleEntry(i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>remove方法也很简单，通过Key（当前的ThreadLocal）的Hash作为Entry数组的某个坐标，找到目标Entry，直接clear（弱引用内部固有方法）。</p>\n<h3 id=\"entry数组扩容\">Entry数组扩容<a title=\"#entry数组扩容\" href=\"#entry数组扩容\"></a></h3>\n<p>通过<code>rehash()</code>方法进行判断扩容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Re-pack and/or re-size the table. First scan the entire</span></span><br><span class=\"line\"><span class=\"comment\"> * table removing stale entries. If this doesn&#x27;t sufficiently</span></span><br><span class=\"line\"><span class=\"comment\"> * shrink the size of the table, double the table size.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rehash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    expungeStaleEntries();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &gt;= threshold - threshold / <span class=\"number\">4</span>)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>扩容条件：数组中含有是实例数大于等于threshold 的四分之三（threshold为数组长度的 三分之二）。</p>\n<p>resize方法是实际扩容算法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Double the capacity of the table.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Entry[] oldTab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldLen = oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newLen = oldLen * <span class=\"number\">2</span>;</span><br><span class=\"line\">    Entry[] newTab = <span class=\"keyword\">new</span> Entry[newLen];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class=\"line\">        Entry e = oldTab[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                e.value = <span class=\"keyword\">null</span>; <span class=\"comment\">// Help the GC</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (newTab[h] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    h = nextIndex(h, newLen);</span><br><span class=\"line\">                newTab[h] = e;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    setThreshold(newLen);</span><br><span class=\"line\">    size = count;</span><br><span class=\"line\">    table = newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>扩容的核心是数组的替换和复制。</li>\n<li>新数组大小为老数组的两倍。</li>\n<li>复制，算出index值，向扩容数组中存储，如果该节点冲突，向后找到为null的节点，然后存储。</li>\n</ol>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li><a href=\"https://www.cnblogs.com/mingfeng002/p/11917883.html\">https://www.cnblogs.com/mingfeng002/p/11917883.html</a></li>\n<li><a href=\"https://juejin.cn/post/6958991265933295624\">https://juejin.cn/post/6958991265933295624</a></li>\n</ul>\n","prev":{"title":"Android开发之UI线程和非UI线程","link":"posts/1557641723"},"next":{"title":"Java并发编程（一）线程基础","link":"posts/1557641189"},"plink":"https://blog.ixin.run/posts/1557641270/","toc":[{"id":"threadlocal是什么","title":"ThreadLocal是什么","index":"1"},{"id":"threadlocal使用","title":"ThreadLocal使用","index":"2"},{"id":"handler中looper和threadlocal的关系","title":"Handler中Looper和ThreadLocal的关系","index":"3"},{"id":"threadlocal原理剖析","title":"ThreadLocal原理剖析","index":"4","children":[{"id":"set方法","title":"set方法","index":"4.1"},{"id":"entry为什么是弱引用类型","title":"Entry为什么是弱引用类型","index":"4.2"},{"id":"entry环形数组","title":"Entry环形数组","index":"4.3"},{"id":"get方法","title":"get方法","index":"4.4"},{"id":"remove方法","title":"remove方法","index":"4.5"},{"id":"entry数组扩容","title":"Entry数组扩容","index":"4.6"}]},{"id":"参考","title":"参考","index":"5"}],"reward":true,"copyright":{"author":"乂星人","link":"<a href=\"https://blog.ixin.run/posts/1557641270/\" title=\"Java并发编程（三）ThreadLocal探讨\">https://blog.ixin.run/posts/1557641270/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}