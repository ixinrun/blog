{"title":"EventBus实现原理及使用","date":"2020-01-08T10:32:18.000Z","date_formatted":{"ll":"2020年1月8日","L":"2020/01/08","MM-DD":"01-08"},"link":"posts/1578479538","comments":true,"tags":["EventBus"],"categories":["Android"],"updated":"2022-01-10T14:45:52.900Z","content":"<p>EventBus是适用于 Android 和 Java的发布/订阅事件总线，具有代码简洁小而快的特点，<a href=\"https://github.com/greenrobot/EventBus\" target=\"_blank\">GitHub地址</a>，EventBus核心思想是通过观察模式，总线式进行消息分发，本篇文章总结一下EventBus的使用方式和原理分析。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEBf630b2e86ef4f69d1767e9c19691c75b?method=download&amp;shareKey=de9e247add3047889f0fdad79a5472ac\" alt=\"EventBus事件流\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"eventbus3.0-vs-eventbus2.0\">EventBus3.0 vs EventBus2.0<a title=\"#eventbus3.0-vs-eventbus2.0\" href=\"#eventbus3.0-vs-eventbus2.0\"></a></h2>\n<p>EventBus3.0相比2.0在代码编写上更加人性化，2.0的时候事件订阅（接收函数）的遍历采用反射的形式，3.0时加入了APT编译时注解。</p>\n<p>3.0事件接收时直接可以在<strong>注解里指定接收线程</strong>，也<strong>不再强制固定函数名</strong>，2.0中函数名必须是<code>onEvent+线程名</code>组合形式，有以下四种形式：</p>\n<ul>\n<li>onEvent</li>\n<li>onEventMainThread</li>\n<li>onEventBackgroundThread</li>\n<li>onEventAsync</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// eventbus2.0形式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onEvent</span><span class=\"params\">(NotifyEvent event)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// eventbus3.0形式（函数随便命名）</span></span><br><span class=\"line\"><span class=\"meta\">@Subscribe(threadMode = ThreadMode.POSTING)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postingME</span><span class=\"params\">(NotifyEvent event)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"eventbus使用\">EventBus使用<a title=\"#eventbus使用\" href=\"#eventbus使用\"></a></h2>\n<h3 id=\"添加依赖\">添加依赖<a title=\"#添加依赖\" href=\"#添加依赖\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&#x27;org.greenrobot:eventbus:3.0.0&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用三部曲\">使用三部曲<a title=\"#使用三部曲\" href=\"#使用三部曲\"></a></h3>\n<ol>\n<li>定义事件</li>\n<li>注册注销订阅</li>\n<li>发送事件</li>\n</ol>\n<p><strong>1.定义事件</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessageEvent</span> </span>&#123; <span class=\"comment\">/* Additional fields if needed */</span> &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2.注册注销订阅</strong></p>\n<p>声明并注释您的订阅方法，可选择指定线程模式:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Subscribe(threadMode = ThreadMode.MAIN)</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessageEvent</span><span class=\"params\">(MessageEvent event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注册和注销你的订阅者，例如在Android上，Activity和Fragment通常应该根据它们的生命周期进行注册：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onStart();</span><br><span class=\"line\">    EventBus.getDefault().register(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onStop();</span><br><span class=\"line\">    EventBus.getDefault().unregister(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>3.发送事件</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus.getDefault().post(<span class=\"keyword\">new</span> MessageEvent());</span><br></pre></td></tr></table></figure>\n<p>一般情况我们注册的EventBus接受事件地方比较少时，进行订阅时相对来说是非常好找事件在哪个地方接收的。但是当接收事件的地方比较多的时候，看代码就有点懵了，在android studio中推荐一个插件：<code>Eventbus3-intellij-plugin</code>，当然也可以通过全局搜索所订阅的事件进行查找。</p>\n<h3 id=\"四种线程\">四种线程<a title=\"#四种线程\" href=\"#四种线程\"></a></h3>\n<p>EventBus总共有四种线程选择：</p>\n<ul>\n<li>POSTING：默认，表示事件处理函数的线程跟发布事件的线程在同一个线程。</li>\n<li>MAIN：表示事件处理函数的线程在主线程(UI)线程，因此在这里不能进行耗时操作。</li>\n<li>BACKGROUND：表示事件处理函数的线程在后台线程，因此不能进行UI操作。如果发布事件的线程是主线程(UI线程)，那么事件处理函数将会开启一个后台线程，如果果发布事件的线程是在后台线程，那么事件处理函数就使用该线程。</li>\n<li>ASYNC：表示无论事件发布的线程是哪一个，事件处理函数始终会新建一个子线程运行，同样不能进行UI操作。</li>\n</ul>\n<h3 id=\"黏性事件\">黏性事件<a title=\"#黏性事件\" href=\"#黏性事件\"></a></h3>\n<p>所谓的黏性事件，就是指发送了该事件之后再订阅依然能够接收到的事件，使用黏性事件的时候有两个地方需要做些修改。</p>\n<p>一个是订阅事件的地方，注解中追加<code>sticky = true</code>，默认<code>sticky = false</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Subscribe(threadMode = ThreadMode.MAIN, sticky = true)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onGetStickyEvent</span><span class=\"params\">(MessageWrap message)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另一个是发布事件的地方，即调用EventBus的postSticky方法来发布事件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus.getDefault().postSticky(<span class=\"string\">&quot;这是一个粘性事件&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"优先级\">优先级<a title=\"#优先级\" href=\"#优先级\"></a></h3>\n<p>在Subscribe注解中总共有3个参数，最后一个参数<code>priority</code>，指定订阅方法的优先级，整数类型默认是0，值越大表示优先级越大。在某个事件被发布出来的时候，优先级较高的订阅方法会首先接受到事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Subscribe(priority = 1)</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onEvent</span><span class=\"params\">(MessageEvent event)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，只有当两个订阅方法使用相同的ThreadMode参数的时候，它们的优先级才会与priority指定的值挂钩。</p>\n<h3 id=\"取消事件\">取消事件<a title=\"#取消事件\" href=\"#取消事件\"></a></h3>\n<p>你可以在订阅者的事件处理方法中通过调用cancelEventDelivery去中断事件传递的过程。任何下一步的事件都会被取消；之后的订阅者也不会收到事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Called in the same thread (default)</span></span><br><span class=\"line\"><span class=\"meta\">@Subscribe</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onEvent</span><span class=\"params\">(MessageEvent event)</span></span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">EventBus.getDefault().cancelEventDelivery(event) ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里也需要注意一点，事件一般都是被高优先级的订阅者取消传递的，事件取消仅限于<code>ThreadMode.POSTING</code>下才可以使用。</p>\n<h2 id=\"eventbus原理\">EventBus原理<a title=\"#eventbus原理\" href=\"#eventbus原理\"></a></h2>\n<p>要想弄懂EventBus原理只需要关注三个容器：</p>\n<ul>\n<li>typesBySubscriber 存储订阅者和该订阅者下边的所有事件</li>\n<li>subscriptionsByEventType 存储某个事件和所有该事件关联的订阅者，因为某个事件可能被多个订阅者所观察</li>\n<li>stickyEvents 存储粘性事件，订阅的时候优先查找stickyEvents有没有该事件</li>\n</ul>\n<h3 id=\"typesbysubscriber\">typesBySubscriber<a title=\"#typesbysubscriber\" href=\"#typesbysubscriber\"></a></h3>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEBad15f3a1ddc343af926260c7efba95b2?method=download&amp;shareKey=37627710759c0c7ac8f7e15c4d056721\" alt=\"订阅者和所属事件关系表\" loading=\"lazy\" class=\"φbp\"></p>\n<p>EventBus初始时会创建一张表，用于保存订阅者和该订阅者下边的所有事件，订阅者（Subscribe）就是我们注册的Activity或者Fragment。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br></pre></td></tr></table></figure>\n<p>EventBus会在对象register时，使用反射机制遍历对象的方法，将带有<code>@Subscribe</code>标签并且合法的方法加入到typesBySubscriber。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(Object subscriber)</span> </span>&#123;</span><br><span class=\"line\">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class=\"line\">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class=\"line\">                subscribe(subscriber, subscriberMethod);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Must be called in synchronized block</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (subscribedEvents == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        subscribedEvents = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"subscriptionsbyeventtype\">subscriptionsByEventType<a title=\"#subscriptionsbyeventtype\" href=\"#subscriptionsbyeventtype\"></a></h3>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEB08765561eee953abccaf52c58285cccd?method=download&amp;shareKey=f88aa8fef3ab556695c2cd04c53e4ca1\" alt=\"事件和订阅者关系表\" loading=\"lazy\" class=\"φbp\"></p>\n<p>EventBus初始时还会创建另外一张表<code>subscriptionsByEventType</code>，并且在订阅注册遍历<code>@Subscribe</code>时将当前事件和所属的订阅者（Activity或者Fragment）存储到该表中，有可能一个事件被多个订阅者所观察，因此也是一对多的关系。</p>\n<p>接下来就是发送事件的时候遍历<code>subscriptionsByEventType</code>找到所有拥有该事件的订阅者，进一步遍历<code>typesBySubscriber</code>匹配到相同的Event：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postSingleEventForEventType</span><span class=\"params\">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class=\"line\">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (subscriptions != <span class=\"keyword\">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class=\"line\">            postingState.event = event;</span><br><span class=\"line\">            postingState.subscription = subscription;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> aborted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class=\"line\">                aborted = postingState.canceled;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                postingState.event = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                postingState.subscription = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                postingState.canceled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (aborted) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"stickyevents\">stickyEvents<a title=\"#stickyevents\" href=\"#stickyevents\"></a></h3>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEBe25f03a0324216ff9c1dc467dae2a68c?method=download&amp;shareKey=1f31d7daf2aac87956fdc2ab23f614cf\" alt=\"粘性事件存储表\" loading=\"lazy\" class=\"φbp\"></p>\n<p>粘性事件也有一张表<code>stickyEvents</code>，发送粘性事件的时候用来存储粘性事件，key是当前事件的class，value是事件对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postSticky</span><span class=\"params\">(Object event)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span> (stickyEvents) &#123;</span><br><span class=\"line\">           stickyEvents.put(event.getClass(), event);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// Should be posted after it is putted, in case the subscriber wants to remove immediately</span></span><br><span class=\"line\">       post(event);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>然后某个页面注册订阅事件的时候，优先判断注册监听的event是不是sticky的，如果是就会用stickEvents表中找到stickyEvent，如果注册的事件event和stickyEvent一样那么就会执行一次postToSubscription方法，即发送事件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (subscriberMethod.sticky) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (eventInheritance) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class=\"line\">         <span class=\"comment\">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class=\"line\">         <span class=\"comment\">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class=\"line\">         <span class=\"comment\">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class=\"line\">         Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class=\"line\">             Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class=\"line\">                 Object stickyEvent = entry.getValue();</span><br><span class=\"line\">                 checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         Object stickyEvent = stickyEvents.get(eventType);</span><br><span class=\"line\">         checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<p>EventBus原理其实很简单，围绕着<code>register</code>、<code>unRegister</code>和<code>post</code>三点展开，开发过程中EventBus相对来说比较灵活，所以要合理安排管理好所有的事件，不至于特别凌乱，以上是EventBus的知识点，总结不易，点个赞咯。</p>\n","prev":{"title":"View的工作流程及自定义View","link":"posts/1580377955"},"next":{"title":"记一次BuildConfig.DEBUG不准确导致的Bug","link":"posts/1576077775"},"plink":"https://blog.ixin.run/posts/1578479538/","toc":[{"id":"eventbus3.0-vs-eventbus2.0","title":"EventBus3.0 vs EventBus2.0","index":"1"},{"id":"eventbus使用","title":"EventBus使用","index":"2","children":[{"id":"添加依赖","title":"添加依赖","index":"2.1"},{"id":"使用三部曲","title":"使用三部曲","index":"2.2"},{"id":"四种线程","title":"四种线程","index":"2.3"},{"id":"黏性事件","title":"黏性事件","index":"2.4"},{"id":"优先级","title":"优先级","index":"2.5"},{"id":"取消事件","title":"取消事件","index":"2.6"}]},{"id":"eventbus原理","title":"EventBus原理","index":"3","children":[{"id":"typesbysubscriber","title":"typesBySubscriber","index":"3.1"},{"id":"subscriptionsbyeventtype","title":"subscriptionsByEventType","index":"3.2"},{"id":"stickyevents","title":"stickyEvents","index":"3.3"}]},{"id":"总结","title":"总结","index":"4"}],"reward":true,"copyright":{"author":"乂星人","link":"<a href=\"https://blog.ixin.run/posts/1578479538/\" title=\"EventBus实现原理及使用\">https://blog.ixin.run/posts/1578479538/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}