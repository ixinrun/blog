{"title":"App启动的那些事（二）Activity的启动过程分析","date":"2021-02-11T02:52:54.000Z","date_formatted":{"ll":"2021年2月11日","L":"2021/02/11","MM-DD":"02-11"},"link":"posts/1613011974","comments":true,"tags":["开机启动"],"categories":["Android"],"updated":"2022-02-05T09:14:01.708Z","content":"<p>我们平时启动一个Activity很简单，简单到只需要一行代码<code>startActivity(new Intent(mContext, LoginActivity.class));</code>，但是就是这行代码背后的过程却是环环相扣。网上大部分都是大块代码，看的头懵懵的，今天针对这一过程尽量用少量的代码分析一下。</p>\n<a id=\"more\"></a>\n<p>App启动的那些事系列：</p>\n<ul>\n<li><a href=\"https://blog.ixin.run/posts/1618224360\" target=\"_blank\">《App启动的那些事（一）开机启动》</a></li>\n<li><a href=\"https://blog.ixin.run/posts/1613011974\" target=\"_blank\">《App启动的那些事（二）Activity的启动过程分析》</a></li>\n<li><a href=\"https://blog.ixin.run/posts/1517199857\" target=\"_blank\">《App启动的那些事（三）View创建》</a></li>\n</ul>\n<h2 id=\"前言\">前言<a title=\"#前言\" href=\"#前言\"></a></h2>\n<p>启动activity面向的场景有两种形式：</p>\n<ul>\n<li>从一个应用跳转到另外一个应用的顶部activity</li>\n<li>从一个Activity跳转到另外一个Activity</li>\n</ul>\n<p>第一种是应用间跳转，简单到只要给一个包名给一个类名即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setClass(<span class=\"string\">&quot;packageName&quot;</span>,<span class=\"string\">&quot;className&quot;</span>);</span><br><span class=\"line\">startActivity(intent);</span><br></pre></td></tr></table></figure>\n<p>第二种属于应用内部跳转，只要知道注册好的activity：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">startActivity(<span class=\"keyword\">new</span> Intent(mContext, XXXActivity.class));</span><br></pre></td></tr></table></figure>\n<p>所以说无论是应用间启动Activity亦或是应用内启动最终都执行的<code>startActivity内部</code>的逻辑。Launcher启动应用也不例外。</p>\n<h2 id=\"launcher是什么\">Launcher是什么<a title=\"#launcher是什么\" href=\"#launcher是什么\"></a></h2>\n<p>Launcher是一个应用，并且是系统启动后的顶层应用，通过PackageManager遍历获取每一个安装过的应用信息，然后进行排布展示和以及后续的点击启动：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Perform the query to determine which results to show and return a list of them.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;ListItem&gt; <span class=\"title\">makeListItems</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Load all matching activities and sort correctly</span></span><br><span class=\"line\">    List&lt;ResolveInfo&gt; list = onQueryPackageManager(mIntent);</span><br><span class=\"line\">    onSortResultList(list);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Perform query on package manager for list items.  The default</span></span><br><span class=\"line\"><span class=\"comment\">* implementation queries for activities.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> List&lt;ResolveInfo&gt; <span class=\"title\">onQueryPackageManager</span><span class=\"params\">(Intent queryIntent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mPackageManager.queryIntentActivities(queryIntent, <span class=\"comment\">/* no flags */</span> <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"activity启动几步走？\">Activity启动几步走？<a title=\"#activity启动几步走？\" href=\"#activity启动几步走？\"></a></h2>\n<p>从点击Launcher的一个Icon开始，这里参考Api28的源码，我大致总结为以下几步路：</p>\n<h3 id=\"launcher到ams\">Launcher到AMS<a title=\"#launcher到ams\" href=\"#launcher到ams\"></a></h3>\n<p>Activity:</p>\n<ul>\n<li>startActivity</li>\n<li>startActivityForResult</li>\n<li>mInstrumentation.execStartActivity</li>\n</ul>\n<blockquote>\n<p>Instrumentation具有跟踪application及activity生命周期的功能，用于监控app和系统的交互。</p>\n</blockquote>\n<p>Instrumentation:</p>\n<ul>\n<li>execStartActivity</li>\n<li>ActivityManager.getService().startActivity() AIDL方式调用AMS，android10之后背后调的是ActivityTaskManagerService（ATMS）。</li>\n</ul>\n<h3 id=\"ams到applicationthread\">AMS到ApplicationThread<a title=\"#ams到applicationthread\" href=\"#ams到applicationthread\"></a></h3>\n<blockquote>\n<p>ActivityManagerService是Android中最核心的服务之一，负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要，它本身也是一个Binder的实现类，运行在系统服务进程（system_server）之中。</p>\n</blockquote>\n<p>ActivityManagerService：</p>\n<ul>\n<li>startActivity</li>\n<li>startActivityAsUser 这里绑定用户相关的信息</li>\n<li>getActivityStartController().obtainStarter()…execute() 背后调的是ActivityStarter的execute()。</li>\n</ul>\n<blockquote>\n<p>ActivityStarter是用于解释如何启动活动。该类收集所有逻辑，用于确定Intent和flag应如何转换为活动以及相关的任务和堆栈。</p>\n</blockquote>\n<p>ActivityStarter</p>\n<ul>\n<li>startActivityMayWait 或 startActivity // 最终背后都调用的是startActivity</li>\n<li>startActivity</li>\n<li>startActivityUnchecked</li>\n<li>mSupervisor.resumeFocusedStackTopActivityLocked()</li>\n</ul>\n<blockquote>\n<p>ActivityStackSupervisor负责所有Activity栈的管理。AMS的stack管理主要有三个类，ActivityStackSupervisor，ActivityStack和TaskRecord。</p>\n</blockquote>\n<p>ActivityStackSupervisor:</p>\n<ul>\n<li>resumeFocusedStackTopActivityLocked</li>\n<li>mFocusedStack.resumeTopActivityUncheckedLocked()</li>\n</ul>\n<blockquote>\n<p>ActivityStack用来管理系统所有的Activity，内部维护了Activity的所有状态和Activity相关的列表等数据。</p>\n</blockquote>\n<p>ActivityStack:</p>\n<ul>\n<li>resumeTopActivityUncheckedLocked</li>\n<li>resumeTopActivityInnerLocked</li>\n<li>mStackSupervisor.startSpecificActivityLocked()</li>\n</ul>\n<p>在<code>resumeTopActivityInnerLocked</code>方法中我们需要注意的是冷热启动的问题，如果是冷启动，则会走<code>next.showStartingWindow()</code>来加载一个根window，这也是冷启动时出现白屏的原因。</p>\n<blockquote>\n<p>冷启动：启动应用前，系统中没有该应用的任何进程信息Application等，启动5s+。这个时间值是从应用启动（创建进程）开始计算，到完成视图的第一次绘制（即Activity内容对用户可见）为止。<br>\n热启动：启动应用时，后台已有该应用的进程，内存中有应用相关Activity（home键退到桌面），启动1.5s+。<br>\n温启动：启动应用时，后台已有该应用的进程，内存中没有应用相关Activity（back键退出应用，未清除进程），启动2s+。</p>\n</blockquote>\n<p>接下来走到<code>ActivityStackSupervisor的startSpecificActivityLocked</code>中，这里判断和开启进程创建过程，如果进程已创建则继续走<code>realStartActivityLocked</code>方法。</p>\n<p>ActivityStackSupervisor:</p>\n<ul>\n<li>startSpecificActivityLocked</li>\n<li>realStartActivityLocked</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">realStartActivityLocked</span><span class=\"params\">(ActivityRecord r, WindowProcessController proc,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">         <span class=\"keyword\">boolean</span> andResume, <span class=\"keyword\">boolean</span> checkConfig)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"comment\">// Create activity launch transaction.</span></span><br><span class=\"line\">             <span class=\"comment\">// ClientTransaction是包含一系列的待客户端处理的事务的容器，客户端接收后取出事务并执行。</span></span><br><span class=\"line\">             <span class=\"keyword\">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(</span><br><span class=\"line\">                     proc.getThread(), r.appToken);</span><br><span class=\"line\">             <span class=\"comment\">// 这里准备启动activity的各种条件      </span></span><br><span class=\"line\">             clientTransaction.addCallback(LaunchActivityItem.obtain(<span class=\"keyword\">new</span> Intent(r.intent),</span><br><span class=\"line\">                     System.identityHashCode(r), r.info,</span><br><span class=\"line\">                     <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Have this take the merged configuration instead of separate global</span></span><br><span class=\"line\">                     <span class=\"comment\">// and override configs.</span></span><br><span class=\"line\">                     mergedConfiguration.getGlobalConfiguration(),</span><br><span class=\"line\">                     mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class=\"line\">                     r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class=\"line\">                     r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class=\"line\">                     profilerInfo));</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"comment\">// Set desired final state.</span></span><br><span class=\"line\">             <span class=\"keyword\">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (andResume) &#123;</span><br><span class=\"line\">                 <span class=\"comment\">// 这里是触发Activity的onResume的根ResumeActivityItem</span></span><br><span class=\"line\">                 lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());</span><br><span class=\"line\">             &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                 lifecycleItem = PauseActivityItem.obtain();</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"comment\">// Schedule transaction.</span></span><br><span class=\"line\">             <span class=\"comment\">// AMS调度该事物，启动activity</span></span><br><span class=\"line\">             mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class=\"line\"></span><br><span class=\"line\">             ...</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>ClientTransaction事务的准备工作完毕后，接下来AMS获取到ClientLifecycleManager实例走事务调度过程，而<code>ClientLifecycleManager.scheduleTransaction()</code>的背后却是调用IApplicationThread的scheduleTransaction方法。由于IApplicationThread是ApplicationThread在系统进程的代理，所以真正执行的地方就是客户端的ApplicationThread中了。也就是说，<strong>Activity启动的操作又跨进程的还给了客户端</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ClientLifecycleManager的scheduleTransaction方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTransaction</span><span class=\"params\">(ClientTransaction transaction)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> IApplicationThread client = transaction.getClient();</span><br><span class=\"line\">    transaction.schedule();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(client <span class=\"keyword\">instanceof</span> Binder)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If client is not an instance of Binder - it&#x27;s a remote call and at this point it is</span></span><br><span class=\"line\">        <span class=\"comment\">// safe to recycle the object. All objects used for local calls will be recycled after</span></span><br><span class=\"line\">        <span class=\"comment\">// the transaction is executed on client in ActivityThread.</span></span><br><span class=\"line\">        transaction.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">schedule</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 最终走的是代理客户端IApplicationThread的scheduleTransaction()</span></span><br><span class=\"line\">    mClient.scheduleTransaction(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们稍稍梳理下：启动Activity的操作从客户端<code>跨进程</code>转移到AMS，AMS通过ActivityStarter、ActivityStack、ActivityStackSupervisor 对 Activity任务、activity栈、Activity记录管理后，又用过跨进程把正在启动过程又转移到了客户端。</p>\n<h3 id=\"iapplicationthread到activitythread\">IApplicationThread到ActivityThread<a title=\"#iapplicationthread到activitythread\" href=\"#iapplicationthread到activitythread\"></a></h3>\n<p>上边的IApplicationThread既然是代理，那我们就看一下ApplicationThread的scheduleTransaction方法，然而发现方法的内部实则调用的<code>ActivityThread.this.scheduleTransaction(transaction);</code>，继续深入实则是ActivityThread父类ClientTransactionHandler的scheduleTransaction方法。</p>\n<blockquote>\n<p>ApplicationThread是ActivityThread的内部类，继承IApplicationThread.Stub，是一个IBinder，是ActiivtyThread和AMS通信的桥梁，AMS则通过代理调用此App进程的本地方法，运行在Binder线程池。</p>\n</blockquote>\n<p>ApplicationThread：</p>\n<ul>\n<li>scheduleTransaction</li>\n<li>ActivityThread.this.scheduleTransaction()</li>\n</ul>\n<blockquote>\n<p>ActivityThread是应用的入口类，系统通过调用main函数，开启消息循环队列。ActivityThread所在线程被称为应用的主线程（UI线程）。</p>\n</blockquote>\n<p>ActivityThread（ClientTransactionHandler）:</p>\n<ul>\n<li>scheduleTransaction()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTransaction</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">    transaction.preExecute(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行到这里接着使用ApplicationThread的sendMessage，通过查找<code>EXECUTE_TRANSACTION</code>指令，得到消息背后的实现<code>TransactionExecutor的execute</code>。</p>\n<p>TransactionExecutor：</p>\n<ul>\n<li>execute</li>\n<li>executeCallbacks()</li>\n</ul>\n<p>在executeCallbacks方法中通过不断遍历callbacks，调用ClientTransactionItem的execute方法，实际最终走到ActivityThread的handleLaunchActivity。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class=\"line\">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">&quot;activityStart&quot;</span>);</span><br><span class=\"line\">    ActivityClientRecord r = <span class=\"keyword\">new</span> ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class=\"line\">            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class=\"line\">            mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class=\"line\">            mProfilerInfo, client, mAssistToken);</span><br><span class=\"line\">    client.handleLaunchActivity(r, pendingActions, <span class=\"keyword\">null</span> <span class=\"comment\">/* customIntent */</span>);</span><br><span class=\"line\">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个sendMessage过程其实是一个线程切换过程，从服务器binder线程池调度到客户端主线程的切换。</p>\n<p>ActivityThread：</p>\n<ul>\n<li>handleLaunchActivity</li>\n<li>performLaunchActivity()</li>\n</ul>\n<p>ActivityThread的handleLaunchActivity方法中最终把启动activity的重任交给了performLaunchActivity了。</p>\n<h3 id=\"activity启动核心-————-performlaunchactivity\">Activity启动核心 ———— performLaunchActivity<a title=\"#activity启动核心-————-performlaunchactivity\" href=\"#activity启动核心-————-performlaunchactivity\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**  activity 启动的核心实现. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Activity <span class=\"title\">performLaunchActivity</span><span class=\"params\">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1、从ActivityClientRecord获取待启动的Activity的组件信息</span></span><br><span class=\"line\">    ActivityInfo aInfo = r.activityInfo;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r.packageInfo == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class=\"line\">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ComponentName component = r.intent.getComponent();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (component == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        component = r.intent.resolveActivity(</span><br><span class=\"line\">            mInitialApplication.getPackageManager());</span><br><span class=\"line\">        r.intent.setComponent(component);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r.activityInfo.targetActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        component = <span class=\"keyword\">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class=\"line\">                r.activityInfo.targetActivity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//创建ContextImpl对象</span></span><br><span class=\"line\">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class=\"line\">    Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//2、创建activity实例</span></span><br><span class=\"line\">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class=\"line\">        activity = mInstrumentation.newActivity(</span><br><span class=\"line\">                cl, component.getClassName(), r.intent);</span><br><span class=\"line\">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class=\"line\">        r.intent.setExtrasClassLoader(cl);</span><br><span class=\"line\">        r.intent.prepareToEnterProcess();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            r.state.setClassLoader(cl);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        ..</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//3、创建Application对象（如果没有的话）</span></span><br><span class=\"line\">        Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class=\"line\">            Configuration config = <span class=\"keyword\">new</span> Configuration(mCompatConfiguration);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.overrideConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                config.updateFrom(r.overrideConfig);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            Window window = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.mPendingRemoveWindow != <span class=\"keyword\">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class=\"line\">                window = r.mPendingRemoveWindow;</span><br><span class=\"line\">                r.mPendingRemoveWindow = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                r.mPendingRemoveWindowManager = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            appContext.setOuterContext(activity);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//4、attach方法为activity关联上下文环境</span></span><br><span class=\"line\">            activity.attach(appContext, <span class=\"keyword\">this</span>, getInstrumentation(), r.token,</span><br><span class=\"line\">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class=\"line\">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class=\"line\">                    r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class=\"line\">                    r.assistToken);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (customIntent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                activity.mIntent = customIntent;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            r.lastNonConfigurationInstances = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            checkAndBlockForNetworkAccess();</span><br><span class=\"line\">            activity.mStartedActivity = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (theme != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                activity.setTheme(theme);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            activity.mCalled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//5、调用生命周期onCreate</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!activity.mCalled) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SuperNotCalledException(</span><br><span class=\"line\">                    <span class=\"string\">&quot;Activity &quot;</span> + r.intent.getComponent().toShortString() +</span><br><span class=\"line\">                    <span class=\"string\">&quot; did not call through to super.onCreate()&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            r.activity = activity;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r.setState(ON_CREATE);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mResourcesManager) &#123;</span><br><span class=\"line\">            mActivities.put(r.token, r);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> activity;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>performLaunchActivity主要完成以下事情：</p>\n<ul>\n<li>从ActivityClientRecord获取待启动的Activity的组件信息</li>\n<li>通过mInstrumentation.newActivity方法使用类加载器创建activity实例</li>\n<li>通过LoadedApk的makeApplication方法创建Application对象，内部也是通过mInstrumentation使用类加载器，创建后就调用了<code>instrumentation.callApplicationOnCreate</code>方法，也就是Application的onCreate方法。</li>\n<li>创建ContextImpl对象并通过activity.attach方法对重要数据初始化，关联了Context的具体实现ContextImpl，attach方法内部还完成了window创建，这样Window接收到外部事件后就能传递给Activity了。</li>\n<li>调用Activity的onCreate方法，是通过 mInstrumentation.callActivityOnCreate方法完成。</li>\n</ul>\n<p>到此整个Activity的创建过程已经走完。</p>\n<h3 id=\"整体流程\">整体流程<a title=\"#整体流程\" href=\"#整体流程\"></a></h3>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/944FDF645B514C0BA42CE7AEAF72D62C?method=download&amp;shareKey=346c928c5a00fa0d057ff33d5b0916dc\" alt=\"Activity启动过程\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"activity的onresume、onpause\">Activity的onResume、onPause<a title=\"#activity的onresume、onpause\" href=\"#activity的onresume、onpause\"></a></h2>\n<p>上边最初启动activity时用LaunchActivityItem来实现远端App端的onCreate生命周期事务，那么控制activity的onResume、onPause、onStop等同样也有类似的XXXItem：</p>\n<ul>\n<li>LaunchActivityItem 远程App端的onCreate生命周期事务</li>\n<li>ResumeActivityItem 远程App端的onResume生命周期事务</li>\n<li>PauseActivityItem 远程App端的onPause生命周期事务</li>\n<li>StopActivityItem 远程App端的onStop生命周期事务</li>\n<li>DestroyActivityItem 远程App端onDestroy生命周期事务</li>\n</ul>\n<h3 id=\"什么时候可见\">什么时候可见<a title=\"#什么时候可见\" href=\"#什么时候可见\"></a></h3>\n<p>我们知道Activity可见是发生在onResume这个过程中，那么我们分析一下这个过程。在上边代码<code>realStartActivityLocked()</code>我有注释，通过<code>clientTransaction.addCallback</code>添加LaunchActivityItem实例后下面接着调用了<code>clientTransaction.setLifecycleStateRequest(lifecycleItem)</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Final lifecycle state in which the client activity should be after the transaction is</span></span><br><span class=\"line\"><span class=\"comment\">    * executed.</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ActivityLifecycleItem mLifecycleStateRequest;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLifecycleStateRequest</span><span class=\"params\">(ActivityLifecycleItem stateRequest)</span> </span>&#123;</span><br><span class=\"line\">       mLifecycleStateRequest = stateRequest;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>mLifecycleStateRequest表示执行transaction后的最终的生命周期状态。</p>\n<p>接下来的处理<code>ActivityThread.H.EXECUTE_TRANSACTION</code>消息，背后实现即TransactionExecutor的execute方法中触发生命周期回调：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + <span class=\"string\">&quot;Start resolving transaction&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> IBinder token = transaction.getActivityToken();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 启动activity</span></span><br><span class=\"line\">    executeCallbacks(transaction);</span><br><span class=\"line\">    <span class=\"comment\">// 启动生命周期</span></span><br><span class=\"line\">    executeLifecycleState(transaction);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来的分析过程和前边一样，最后发现<strong>onResume的触发过程实则是走到了ActivityThread的handleResumeActivity方法中</strong>，handleResumeActivity主要做了以下事情：</p>\n<ul>\n<li>调用生命周期：通过performResumeActivity方法，内部调用生命周期onStart、onResume方法</li>\n<li>设置视图可见：通过activity.makeVisible方法，添加window、设置可见。（所以视图的真正可见是在onResume方法之后）</li>\n</ul>\n<p>在handleResumeActivity方法中先执行performResumeActivity获取ActivityClientRecord的实例，ActivityClientRecord是客户端进程中包装器，内部包含启动activity一切所需的参数，对标的是ActivityRecord（system_server进程中的对象），然后将act的DecorView添加到WindowManager中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// r为ActivityClientRecord的实例</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (r.window == <span class=\"keyword\">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class=\"line\">    r.window = r.activity.getWindow();</span><br><span class=\"line\">    View decor = r.window.getDecorView();</span><br><span class=\"line\">    decor.setVisibility(View.INVISIBLE);</span><br><span class=\"line\">    ViewManager wm = a.getWindowManager();</span><br><span class=\"line\">    WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class=\"line\">    a.mDecor = decor;</span><br><span class=\"line\">    l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class=\"line\">    l.softInputMode |= forwardBit;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r.mPreserveWindow) &#123;</span><br><span class=\"line\">        a.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        r.mPreserveWindow = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Normally the ViewRoot sets up callbacks with the Activity</span></span><br><span class=\"line\">        <span class=\"comment\">// in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span></span><br><span class=\"line\">        <span class=\"comment\">// the decor view we have to notify the view root that the</span></span><br><span class=\"line\">        <span class=\"comment\">// callbacks may have changed.</span></span><br><span class=\"line\">        ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (impl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            impl.notifyChildRebuilt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.mVisibleFromClient) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!a.mWindowAdded) &#123;</span><br><span class=\"line\">            a.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            wm.addView(decor, l);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The activity will get a callback for this &#123;@link LayoutParams&#125; change</span></span><br><span class=\"line\">            <span class=\"comment\">// earlier. However, at that time the decor will not be set (this is set</span></span><br><span class=\"line\">            <span class=\"comment\">// in this method), so no action will be taken. This call ensures the</span></span><br><span class=\"line\">            <span class=\"comment\">// callback occurs with the decor set.</span></span><br><span class=\"line\">            a.onWindowAttributesChanged(l);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If the window has already been added, but during resume</span></span><br><span class=\"line\">    <span class=\"comment\">// we started another activity, then don&#x27;t yet make the</span></span><br><span class=\"line\">    <span class=\"comment\">// window visible.</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!willBeVisible) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (localLOGV) Slog.v(TAG, <span class=\"string\">&quot;Launch &quot;</span> + r + <span class=\"string\">&quot; mStartedActivity set&quot;</span>);</span><br><span class=\"line\">    r.hideForNow = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后调用<code>r.activity.makeVisible()</code>，即Activity的makeVisible()方法，此时Activity得以显示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">makeVisible</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mWindowAdded) &#123;</span><br><span class=\"line\">        ViewManager wm = getWindowManager();</span><br><span class=\"line\">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class=\"line\">        mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 界面显示</span></span><br><span class=\"line\">    mDecor.setVisibility(View.VISIBLE);</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<p>Activity的启动过程在我看来主要经历了四个过程：</p>\n<ul>\n<li>启动的发起 （Launcher到AMS）</li>\n<li>AMS的管理（AMS到ApplicationThread）</li>\n<li>线程切换（IApplicationThread到ActivityThread）</li>\n<li>启动核心（performLaunchActivity）</li>\n</ul>\n<p>启动过程经历了两次IPC：</p>\n<ul>\n<li>客户端到AMS</li>\n<li>AMS到客户端</li>\n</ul>\n<p>这块知识比较碎，但是真的贯通在一起了，大的方向一点也不凌乱，看系统源码时枯燥的，学的是一个方法论，抓主线，定方向。</p>\n","prev":{"title":"属于我们的0214","link":"posts/1613285792"},"next":{"title":"Java多态小记","link":"posts/1612714489"},"plink":"https://blog.ixin.run/posts/1613011974/","toc":[{"id":"前言","title":"前言","index":"1"},{"id":"launcher是什么","title":"Launcher是什么","index":"2"},{"id":"activity启动几步走？","title":"Activity启动几步走？","index":"3","children":[{"id":"launcher到ams","title":"Launcher到AMS","index":"3.1"},{"id":"ams到applicationthread","title":"AMS到ApplicationThread","index":"3.2"},{"id":"iapplicationthread到activitythread","title":"IApplicationThread到ActivityThread","index":"3.3"},{"id":"activity启动核心-————-performlaunchactivity","title":"Activity启动核心 ———— performLaunchActivity","index":"3.4"},{"id":"整体流程","title":"整体流程","index":"3.5"}]},{"id":"activity的onresume、onpause","title":"Activity的onResume、onPause","index":"4","children":[{"id":"什么时候可见","title":"什么时候可见","index":"4.1"}]},{"id":"总结","title":"总结","index":"5"}],"reward":true,"copyright":{"author":"乂星人","link":"<a href=\"https://blog.ixin.run/posts/1613011974/\" title=\"App启动的那些事（二）Activity的启动过程分析\">https://blog.ixin.run/posts/1613011974/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}