{"title":"Android应用卡顿监测总结","date":"2021-03-08T08:36:28.000Z","date_formatted":{"ll":"2021年3月8日","L":"2021/03/08","MM-DD":"03-08"},"link":"posts/1615192588","comments":true,"tags":["性能优化"],"categories":["Android"],"updated":"2022-08-25T14:14:20.384Z","content":"<p>为什么感觉很卡顿，因为一瞬间人眼能看到画面过渡明显有断层。人眼能识别最高24帧的连续画面，为了看起来更流畅，android提供60帧的画面绘制频率，即每隔16毫秒渲染一次画面，超过16毫秒就表示卡顿了。</p>\n<h2 id=\"卡顿原因分析\">卡顿原因分析<a title=\"#卡顿原因分析\" href=\"#卡顿原因分析\"></a></h2>\n<ol>\n<li>线程耗时；</li>\n<li>布局嵌套过深；</li>\n<li>同一时间动画执行的次数过多；</li>\n<li>View的过度绘制，导致了某些像素在同一帧时间内被绘制多次,从而使CPU或GPU负载过重；</li>\n<li>View频繁绘制出触发measure、layout，导致measure和layout累计耗时过多及整个View频繁的重新渲染；</li>\n<li>内存频繁触发GC过多，导致暂时阻塞渲染操作；</li>\n<li>冗余资源及逻辑等导致加载和执行缓慢；</li>\n<li>ANR（在主线程中做了耗时操作） UI卡顿=轻量版的ANR</li>\n</ol>\n<h2 id=\"常见工具检测\">常见工具检测<a title=\"#常见工具检测\" href=\"#常见工具检测\"></a></h2>\n<ul>\n<li><a href=\"https://blog.csdn.net/zhzhangnews/article/details/91562336\" target=\"_blank\">Android Profile</a></li>\n<li>Systrace</li>\n<li>严苛模式——StrictMode</li>\n</ul>\n<h2 id=\"自动化检测方式\">自动化检测方式<a title=\"#自动化检测方式\" href=\"#自动化检测方式\"></a></h2>\n<ul>\n<li>Looper日志拦截</li>\n<li>Choreographer监测帧率</li>\n</ul>\n<h3 id=\"looper日志拦截\">Looper日志拦截<a title=\"#looper日志拦截\" href=\"#looper日志拦截\"></a></h3>\n<p>Android 主线程运行的本质，其实就是 Message 的处理过程，我们的各种操作，包括每一帧的渲染操作 ，都是通过 Message 的形式发给主线程的 MessageQueue ，MessageQueue 处理完消息继续等下一个消息。</p>\n<p>Android主线程更新UI。如果界面1秒钟刷新少于60次，即FPS小于60，用户就会产生卡顿感觉。简单来说，Android使用消息机制进行UI更新，UI线程有个Looper，在其loop方法中会不断取出message，调用其绑定的Handler在UI线程执行。如果在handler的dispatchMesaage方法里有耗时操作，就会发生卡顿。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// might block</span></span><br><span class=\"line\">        <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class=\"line\">        Printer logging = me.mLogging;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            logging.println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class=\"string\">&quot; &quot;</span> +</span><br><span class=\"line\">                    msg.callback + <span class=\"string\">&quot;: &quot;</span> + msg.what);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// focus</span></span><br><span class=\"line\">        msg.target.dispatchMessage(msg);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            logging.println(<span class=\"string\">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class=\"string\">&quot; &quot;</span> + msg.callback);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.recycleUnchecked();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码可以看到，如果设置了logging，会分别打印出<code>&gt;&gt;&gt;&gt;&gt; Dispathcing to</code>和<code>&lt;&lt;&lt;&lt;&lt; Finished to</code>这样的log，所以我们只要计算这两个Log的时间差是否某个伐值（比如说1000毫秒，表示非常卡顿了，我们要分析一下），即可判断是否处于卡顿状态。</p>\n<p>那么如何抓取日志呢？Looper是可以设置我们自己的打印器的。</p>\n<p>在实际实现中，不同手机不同Android系统甚至是不同的ROM版本，Loop函数不一定都能打印出”&gt;&gt;&gt;&gt;&gt; Dispatching to “和”&lt;&lt;&lt;&lt;&lt; Finished to “这样的日志，导致该方式无法进行。</p>\n<p>优化的策略：我们知道Loop函数开始和结束必会执行println打印日志，所以优化版本将卡顿的判断改为，Loop输出第一句log时当作startMonitor，输出下一句log时当作end时刻来解决这个问题。</p>\n<h3 id=\"choreographer.framecallback监控卡顿\">Choreographer.FrameCallback监控卡顿<a title=\"#choreographer.framecallback监控卡顿\" href=\"#choreographer.framecallback监控卡顿\"></a></h3>\n<p>Android系统每隔16ms发出VSYNC信号，来通知界面进行重绘、渲染，每一次同步的周期为16.6ms，代表一帧的刷新频率。</p>\n<p>SDK中包含了一个相关类，以及相关回调。理论上来说两次回调的时间周期应该在16ms，如果超过了16ms我们则认为发生了卡顿，利用两次回调间的时间周期来判断是否发生卡顿（这个方案是Android 4.1 API 16以上才支持）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Choreographer.getInstance().postFrameCallback(<span class=\"keyword\">new</span> Choreographer.FrameCallback() &#123; </span><br><span class=\"line\">                <span class=\"keyword\">long</span> lastFrameTimeNanos = <span class=\"number\">0</span>; </span><br><span class=\"line\">                <span class=\"keyword\">long</span> currentFrameTimeNanos = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 一次界面渲染会回调doFrame方法</span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFrame</span><span class=\"params\">(<span class=\"keyword\">long</span> frameTimeNanos)</span> </span>&#123; </span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(lastFrameTimeNanos == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                        lastFrameTimeNanos == frameTimeNanos;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    currentFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 两次界面渲染时间差</span></span><br><span class=\"line\">                    <span class=\"keyword\">long</span> diffMs = TimeUnit.MILLISECONDS.convert(currentFrameTimeNanos-lastFrameTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 丢帧次数（每一帧16.6毫秒）</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> frames = (<span class=\"keyword\">int</span>) (times / <span class=\"number\">16.6</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (diffMs &gt; <span class=\"number\">16.6f</span>) &#123;            </span><br><span class=\"line\">                       Log.w(TAG, <span class=\"string\">&quot;UI线程超时(超过16ms):&quot;</span> + times + <span class=\"string\">&quot;ms&quot;</span> + <span class=\"string\">&quot; , 丢帧:&quot;</span> + frames);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    Choreographer.getInstance().postFrameCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<p>Choreographer周期性的在UI重绘时候触发，在代码中记录上一次和下一次绘制的时间间隔，如果超过16ms，就意味着一次UI线程重绘的“丢帧”。丢帧的数量为间隔时间除以16，如果超过3，就开始有卡顿的感知。</p>\n<h3 id=\"choreographer简要原理\">Choreographer简要原理<a title=\"#choreographer简要原理\" href=\"#choreographer简要原理\"></a></h3>\n<p>Choreographer 的引入，主要是配合 Vsync ，给上层 App 的渲染提供一个稳定的 Message 处理的时机，也就是 Vsync 到来的时候 ，系统通过对 Vsync 信号周期的调整，来控制每一帧绘制操作的时机. 目前大部分手机都是 60Hz 的刷新率，也就是 16.6ms 刷新一次，系统为了配合屏幕的刷新频率，将 Vsync 的周期也设置为 16.6 ms，每个 16.6 ms ， Vsync 信号唤醒 Choreographer 来做 App 的绘制操作 ，这就是引入 Choreographer 的主要作用。</p>\n<p><strong>Choreographer 两个主要作用</strong></p>\n<ol>\n<li>承上：负责接收和处理 App 的各种更新消息和回调，等到 Vsync 到来的时候统一处理。比如集中处理 Input(主要是 Input 事件的处理) 、Animation(动画相关)、Traversal(包括 measure、layout、draw 等操作) ，判断卡顿掉帧情况，记录 CallBack 耗时等。</li>\n<li>启下：负责请求和接收 Vsync 信号。接收 Vsync 事件回调(通过 FrameDisplayEventReceiver.onVsync )；请求 Vsync(FrameDisplayEventReceiver.scheduleVsync)。</li>\n</ol>\n<p>Choreographer原理：<a href=\"https://www.jianshu.com/p/996bca12eb1d\">https://www.jianshu.com/p/996bca12eb1d</a></p>\n<h2 id=\"anr异常\">ANR异常<a title=\"#anr异常\" href=\"#anr异常\"></a></h2>\n<p>ANR异常全称 Application Not Responding，即应用无响应。如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框。</p>\n<p>发生ANR到弹框在不同的组件之间时间定义是不一样的：</p>\n<ul>\n<li>Activit是5秒</li>\n<li>前台广播10秒，后台广播60秒</li>\n<li>前台服务20秒，后台服务200秒</li>\n</ul>\n<p>这些数据都定义在AMS中，ANR的日志在data/anr/traces.txt目录下。</p>\n<p>线上ANR检测方案：</p>\n<ul>\n<li>线上我们可以使用FileObserver监控文件变化，但是这种方法在高版本系统中有权限问题。</li>\n<li>另外一种就是使用AnrWatchDog框架。这也是一个开源框架，地址：<a href=\"https://github.com/SalomonBrys/ANR-WatchDog%E3%80%82%E5%AE%83%E7%9A%84%E5%8E%9F%E7%90%86%E5%B0%B1%E6%98%AF%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%A4%E6%96%ADUI%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%91%E7%94%9F%E5%8D%A1%E9%A1%BF%E3%80%82\">https://github.com/SalomonBrys/ANR-WatchDog。它的原理就是通过修改值的方式判断UI线程是否发生卡顿。</a></li>\n</ul>\n<p>ANR原理：<a href=\"https://segmentfault.com/a/1190000022967452\">https://segmentfault.com/a/1190000022967452</a></p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/MthGj4AwFPL2JrZ0x1i4fw\">https://mp.weixin.qq.com/s/MthGj4AwFPL2JrZ0x1i4fw</a></li>\n<li><a href=\"https://blog.csdn.net/siyemuzi/article/details/102896685\">https://blog.csdn.net/siyemuzi/article/details/102896685</a></li>\n<li><a href=\"https://juejin.cn/post/6844904195146022920\">https://juejin.cn/post/6844904195146022920</a></li>\n<li><a href=\"http://gityuan.com/2016/12/31/input-ipc/\">http://gityuan.com/2016/12/31/input-ipc/</a></li>\n</ul>\n","prev":{"title":"Http协议原理知多少","link":"posts/1615211970"},"next":{"title":"你了解android的进程间通信吗","link":"posts/1615119064"},"plink":"https://blog.ixin.run/posts/1615192588/","toc":[{"id":"卡顿原因分析","title":"卡顿原因分析","index":"1"},{"id":"常见工具检测","title":"常见工具检测","index":"2"},{"id":"自动化检测方式","title":"自动化检测方式","index":"3","children":[{"id":"looper日志拦截","title":"Looper日志拦截","index":"3.1"},{"id":"choreographer.framecallback监控卡顿","title":"Choreographer.FrameCallback监控卡顿","index":"3.2"},{"id":"choreographer简要原理","title":"Choreographer简要原理","index":"3.3"}]},{"id":"anr异常","title":"ANR异常","index":"4"},{"id":"参考","title":"参考","index":"5"}],"reward":true,"copyright":{"author":"乂星人","link":"<a href=\"https://blog.ixin.run/posts/1615192588/\" title=\"Android应用卡顿监测总结\">https://blog.ixin.run/posts/1615192588/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}