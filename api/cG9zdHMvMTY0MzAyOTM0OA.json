{"title":"Flutter渲染机制","date":"2022-01-24T13:02:11.000Z","date_formatted":{"ll":"2022年1月24日","L":"2022/01/24","MM-DD":"01-24"},"link":"posts/1643029348","comments":true,"categories":["Flutter"],"updated":"2022-08-25T14:14:20.388Z","content":"<p>渲染机制似乎是所有前端框架开发者都要深入了解的知识。</p>\n<a id=\"more\"></a>\n<h2 id=\"绘图原理\">绘图原理<a title=\"#绘图原理\" href=\"#绘图原理\"></a></h2>\n<p>计算机绘图原理：</p>\n<p><strong>屏幕显示器一般以60Hz的固定频率刷新，每一帧图像绘制完成后，会继续绘制下一帧，这时显示器就会发出一个Vsync信号，按60Hz计算，屏幕每秒会发出60次这样的信号。CPU计算好显示内容提交给GPU，GPU渲染好传递给显示器显示。</strong></p>\n<p>Flutter也遵循这种模式：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/3FDBBF766B3E4BEBA9EB8416FDEA0937?method=download&amp;shareKey=3a7eea1108bc13fcf1fd53612aacd9bb\" alt=\"Flutter渲染流程图\" loading=\"lazy\"></p>\n<ul>\n<li>GPU的VSync信号同步给到UI线程，UI线程使用Dart来构建抽象的视图结构</li>\n<li>绘制好的抽象视图数据结构在GPU线程中进行图层合成，然后提供给Skia引擎渲染为GPU数据，最后通过OpenGL或者 Vulkan提供给 GPU。</li>\n</ul>\n<h2 id=\"flutter框架\">Flutter框架<a title=\"#flutter框架\" href=\"#flutter框架\"></a></h2>\n<p>flutter架构主要分三部分：</p>\n<ol>\n<li>framework 主要有Dart开发业务逻辑和各种UI组件。</li>\n<li>engine 主要使用 C++ 编写，提供了 Flutter 核心 API 的底层实现。</li>\n<li>embedder 充当着宿主操作系统和 Flutter 之间的粘合剂的角色，类似java和c通信的jni层。</li>\n</ol>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/855958749F1A4B5DB6BE38D53D276AC0?method=download&amp;shareKey=81761a6c6b58aa487ae013955f10392e\" alt=\"Flutter架构概览\" loading=\"lazy\" class=\"φbp\"></p>\n<p>其中负责渲染的主要是framework和engine。</p>\n<h3 id=\"framework\">Framework<a title=\"#framework\" href=\"#framework\"></a></h3>\n<p>Flutter Framework 是一个纯 Dart实现的 SDK。它实现了一套基础库， 用于处理动画、绘图和手势。并且基于绘图封装了一套 UI组件库，然后根据 Material 和Cupertino两种视觉风格区分开来。这个纯 Dart实现的 SDK被封装为了一个叫作 dart:ui的 Dart库。我们在使用 Flutter写 App的时候，直接导入这个库即可使用组件等功能。</p>\n<h3 id=\"engine\">Engine<a title=\"#engine\" href=\"#engine\"></a></h3>\n<p>Flutter Engine 是一个纯 C++实现的 SDK。囊括了 Skia引擎、Dart运行时、文字排版引擎等。它是 Dart的一个运行时，它可以以 JIT、JIT Snapshot 或者 AOT的模式运行 Dart代码。这个运行时还控制着 VSync信号的传递、GPU数据的填充等，并且还负责把客户端的事件传递到运行时中的代码。</p>\n<h2 id=\"绘图流程\">绘图流程<a title=\"#绘图流程\" href=\"#绘图流程\"></a></h2>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/F0002285DA9D4B48864E9DF989B2BBE3?method=download&amp;shareKey=7363667b0c92e6c589b043c73c8a98cf\" alt=\"UI框架绘图流程\" loading=\"lazy\" class=\"φbp\"></p>\n<p>1.首先是获取到用户的操作，然后你的应用会因此显示一些动画，接着 Flutter 开始构建 Widget 对象。</p>\n<p>2.Widget 对象构建完成后进入渲染阶段，这个阶段主要包括三步：</p>\n<ul>\n<li>布局元素：决定页面元素在屏幕上的位置和大小；</li>\n<li>绘制阶段：将页面元素绘制成它们应有的样式；</li>\n<li>合成阶段：按照绘制规则将之前两个步骤的产物组合在一起。</li>\n</ul>\n<p>3.最后的光栅化由 Engine 层来完成。</p>\n<h3 id=\"布局\">布局<a title=\"#布局\" href=\"#布局\"></a></h3>\n<ul>\n<li>布局约束，由父控件约束子控件。父控件通过传递Containers参数，告诉子控件自己的大小（布局约束），以此来决定子控件的位置。</li>\n<li>大小尺寸，由子控件传给父控件。子控件的位置不存储在自己的容器中，而是存储在自己的parentData字段里，所以当他的位置发生变化时，并不需要重新布局或绘制。</li>\n<li>子节点不关心自己所在的位置，父节点也不关心子节点具体长什么样子。</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/DB51D1DB6EF040CEB6B482EDC501588F?method=download&amp;shareKey=aa6d2a2618e37ce6dbfa4fddefa85798\" alt=\"布局约束和大小尺寸\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"flutter三棵树\">Flutter三棵树<a title=\"#flutter三棵树\" href=\"#flutter三棵树\"></a></h2>\n<p>在渲染阶段，有三颗重要的树，Widget树，Element树，Render树。其中，控件树（widget）最终会转换成对应的渲染对象（RenderObject）树，在 Rendering 层进行布局和绘制。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/528F9488C88248D6B8493A78CF1D5C2F?method=download&amp;shareKey=cd9f33a760ce6799a062f12769071eee\" alt=\"Flutter三棵树\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"widget树\">Widget树<a title=\"#widget树\" href=\"#widget树\"></a></h3>\n<ul>\n<li>整个Flutter项目结构也是由很多个Widget构成的, 本质上就是一个Widget Tree。</li>\n<li>Widget里面存储了一个视图的配置信息，包括布局、属性等。</li>\n<li>Widget仅仅是配置文件，比较轻量，不参与直接的绘制。</li>\n<li>Widget频繁创建和销毁不会太影响性能。</li>\n</ul>\n<h3 id=\"element树\">Element树<a title=\"#element树\" href=\"#element树\"></a></h3>\n<ul>\n<li>Element是Widget在树中具有特定位置的是实例化。当一个Widget首次被创建的时候，那么这个Widget会通过Widget.createElement，创建一个element。</li>\n<li>Element创建的同时还持有 Widget和 RenderObject的引用。</li>\n<li>当Widget Tree所依赖的状态发生改变，Element根据拿到之前所保存的旧的Widget和新的Widget做一个对比, 判断两者的Key和类型是否是相同的, 相同的就不需要重新创建，只需要更新对应的属性，并将真正需要修改的部分同步到真实的RenderObject树中。</li>\n</ul>\n<h3 id=\"render树\">Render树<a title=\"#render树\" href=\"#render树\"></a></h3>\n<ul>\n<li>RenderObject层是渲染库的核心，主要负责layout、paint等复杂操作，最终Flutter Engin是把RenderObject真正渲染到界面上的。</li>\n<li>并不是所有的Widget都会被独立渲染，只有继承RenderObjectWidget的才会创建RenderObject对象。</li>\n</ul>\n<h3 id=\"树的创建过程\">树的创建过程<a title=\"#树的创建过程\" href=\"#树的创建过程\"></a></h3>\n<ul>\n<li>Widget隐式调用<code>Widget.createElement</code> 创建一个Element实例，记为element；</li>\n<li>接着调用<code>element.mount(parentElement,newSlot)</code>，将element相关联的renderObject插入到渲染树中，插入到渲染树后的element就处于“active”状态，处于“active”状态后就可以显示在屏幕上了。</li>\n<li>为了进行Element复用，在Element重新构建前会先尝试是否可以复用旧树上相同位置的element，element节点在更新前都会调用其对应Widget的<code>canUpdate</code>方法，主要是判断newWidget与oldWidget的runtimeType和key是否同时相等，如果同时相等就返回true，表示复用旧Element，否则返回false，重新创建。</li>\n</ul>\n<p>大体流程是：根据Widget生成Element，然后创建相应的RenderObject并关联到Element.renderObject属性上，最后再通过RenderObject来完成布局排列和绘制。</p>\n<p>不同的Widget会生成不同的Element，以下是源码中常见额三种Element：</p>\n<ul>\n<li>StatelessElement StatelessWidget会创建StatelessElement，这里主要就是调用build方法，将Element传出去。</li>\n<li>StatefulElement StatefulWidget会创建StatefulElement，创建出来后调用createState方法，创建state，将Widget赋值给state，最后调用state的build方法，并且将Element传出去。</li>\n<li>RenderElement RenderElement主要是创建RenderObject对象，只有继承自RenderObjectWidget的Widget会创建RenderObjectElement，创建步骤先创建RanderElement，创建出来后调用mount方法，在mount方法中会调用createRenderObject方法，来创建RenderObject。</li>\n</ul>\n<h3 id=\"buildcontext\">BuildContext<a title=\"#buildcontext\" href=\"#buildcontext\"></a></h3>\n<p>创建Element之后，创建出来的elment会拿到传过来的widget，然后调用widget自己的build方法。针对StatefulWidget，调用build的时候，调用的是state中的build方法。build方法传入的参数都是Element自己，所以本质上BuildContext就是当前的Element。</p>\n<h2 id=\"构造函数中的key\">构造函数中的Key<a title=\"#构造函数中的key\" href=\"#构造函数中的key\"></a></h2>\n<p>我们在自定义Widget的时候，每一个Widget, 在其构造方法中我们都会看到一个参数Key，其实这个key就是更新Element用的，通过Widget的<code>canUpdate</code>做到有效的增量更新：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class=\"line\">    &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认情况下我们几乎不设置key，Element的重用机制主要靠runtimeType来决定，大部分情况都是可重用的，所以想要Element强制重建，我们可以自定一个唯一的key，传入进去既可。</p>\n<h3 id=\"key的分类\">key的分类<a title=\"#key的分类\" href=\"#key的分类\"></a></h3>\n<p>Key本身是一个抽象类，子类包含LocalKey和GlobalKey。</p>\n<p>LocalKey可以派生出多个子类，用于不同的场景：</p>\n<ul>\n<li>ValueKey 以一个数据作为Key，如：数字，字符</li>\n<li>ObjectKey 以object对象作为Key，例如 ObjectKey(Text(‘222’))</li>\n<li>UniqueKey 可以保证key的唯一性（一旦使用UniqueKey那么就不存在Element复用了）</li>\n</ul>\n<p>GlobalKey 可以获取到对应的widget的state对象，GlobalKey 使用了一个静态常量 Map 来保存它对应的 Element。你可以通过 GlobalKey 找到持有该GlobalKey的 Widget，State 和 Element。需要注意的是：GlobalKey 是非常昂贵的，需要谨慎使用。</p>\n<p>以下是GlobalKey使用场景：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GlobalKeyDemo</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">final</span> GlobalKey&lt;_ChildPageState&gt; _globalKey = GlobalKey();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">    appBar: AppBar(</span><br><span class=\"line\">      title: Text(<span class=\"string\">&#x27;GlobalKeyDemo&#x27;</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    body: ChildPage(</span><br><span class=\"line\">      key: _globalKey,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    floatingActionButton: FloatingActionButton(</span><br><span class=\"line\">      child: Icon(Icons.add),</span><br><span class=\"line\">      onPressed: () &#123;</span><br><span class=\"line\">        _globalKey.currentState.data =</span><br><span class=\"line\">            <span class=\"string\">&#x27;old:&#x27;</span> + _globalKey.currentState.count.toString();</span><br><span class=\"line\">        _globalKey.currentState.count++;</span><br><span class=\"line\"></span><br><span class=\"line\">        _globalKey.currentState.setState(() &#123;&#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">ChildPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">_ChildPageState createState() =&gt; _ChildPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_ChildPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">ChildPage</span>&gt; </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">String</span> data = <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Center(</span><br><span class=\"line\">    child: Column(</span><br><span class=\"line\">      children: &lt;Widget&gt;[</span><br><span class=\"line\">        Text(count.toString()),</span><br><span class=\"line\">        Text(data),</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"提几个问题\">提几个问题<a title=\"#提几个问题\" href=\"#提几个问题\"></a></h2>\n<p>1.createState 方法在什么时候调用？state 里面为啥可以直接获取到 widget 对象？</p>\n<blockquote>\n<p>答：Flutter 会在遍历 Widget 树时调用 Widget 里面的 createElement 方法去生成对应节点的 Element 对象，同时执行 StatefulWidget 里面的 createState 方法创建 state，并且赋值给 Element 里的 _state 属性，当前 widget 也同时赋值给了 state 里的_widget，state 里面有个 widget 的get 方法可以获取到 _widget 对象。</p>\n</blockquote>\n<p>2.build 方法是在什么时候调用的？</p>\n<blockquote>\n<p>答：Element 创建好以后 Flutter 框架会执行 mount 方法，对于非渲染的 ComponentElement 来说 mount 主要执行 widget 里的 build 方法，StatefulElement 执行 build 方法的时候是执行的 state 里面的 build 方法，并且将自身传入，也就是常见的 BuildContext。</p>\n</blockquote>\n<p>3.BuildContext 是什么？</p>\n<blockquote>\n<p>答：StatefulElement 执行 build 方法的时候是执行的 state 里面的 build 方法，并且将自身传入，也就是 常见的 BuildContext。简而言之 BuidContext 就是 Element。</p>\n</blockquote>\n<p>4.Widget 频繁更改创建是否会影响性能？复用和更新机制是什么样的？</p>\n<blockquote>\n<p>答：不会影响性能，widget 只是简单的配置信息，并不直接涉及布局渲染相关。Element 层通过判断新旧 widget 的runtimeType 和 key 是否相同决定是否可以直接更新之前的配置信息，也就是替换之前的 widget，而不必每次都重新创建新的 Element。</p>\n</blockquote>\n<p>5.创建 Widget 里面的 Key 到底是什么作用？</p>\n<blockquote>\n<p>答：Key 作为 Widget 的标志，在widget 变更的时候通过判断 Element 里面之前的 widget 的 runtimeType 和 key来决定是否能够直接更新。</p>\n</blockquote>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/9650780dcbf5\">https://www.jianshu.com/p/9650780dcbf5</a></li>\n<li><a href=\"https://www.jianshu.com/p/bcc74f37aba5\">https://www.jianshu.com/p/bcc74f37aba5</a></li>\n<li><a href=\"https://www.jianshu.com/p/7fe3cedb67da\">https://www.jianshu.com/p/7fe3cedb67da</a></li>\n</ul>\n","prev":{"title":"浅谈Android和Flutter暗黑模式","link":"posts/1644985990"},"next":{"title":"Flutter状态管理器","link":"posts/1642727866"},"plink":"https://blog.ixin.run/posts/1643029348/","toc":[{"id":"绘图原理","title":"绘图原理","index":"1"},{"id":"flutter框架","title":"Flutter框架","index":"2","children":[{"id":"framework","title":"Framework","index":"2.1"},{"id":"engine","title":"Engine","index":"2.2"}]},{"id":"绘图流程","title":"绘图流程","index":"3","children":[{"id":"布局","title":"布局","index":"3.1"}]},{"id":"flutter三棵树","title":"Flutter三棵树","index":"4","children":[{"id":"widget树","title":"Widget树","index":"4.1"},{"id":"element树","title":"Element树","index":"4.2"},{"id":"render树","title":"Render树","index":"4.3"},{"id":"树的创建过程","title":"树的创建过程","index":"4.4"},{"id":"buildcontext","title":"BuildContext","index":"4.5"}]},{"id":"构造函数中的key","title":"构造函数中的Key","index":"5","children":[{"id":"key的分类","title":"key的分类","index":"5.1"}]},{"id":"提几个问题","title":"提几个问题","index":"6"},{"id":"参考","title":"参考","index":"7"}],"reward":true,"copyright":{"author":"乂星人","link":"<a href=\"https://blog.ixin.run/posts/1643029348/\" title=\"Flutter渲染机制\">https://blog.ixin.run/posts/1643029348/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}