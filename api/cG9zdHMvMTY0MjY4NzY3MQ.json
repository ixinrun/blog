{"title":"Flutter生命周期","date":"2022-01-20T14:07:51.000Z","date_formatted":{"ll":"2022年1月20日","L":"2022/01/20","MM-DD":"01-20"},"link":"posts/1642687671","comments":true,"categories":["Flutter"],"updated":"2022-02-05T09:14:01.712Z","content":"<p>提到生命周期太过熟悉，无论android、iOS还是flutter开发，都离不开围绕着生命周期转。生命周期顾名思义就是一个活动从开始创建到结束所经历的这个过程。</p>\n<a id=\"more\"></a>\n<h2 id=\"前言\">前言<a title=\"#前言\" href=\"#前言\"></a></h2>\n<p>我们知道Flutter是面向组件开发，一切皆Widget，所以常说Flutter的生命周期主要是指Widget的生命周期，常见的Widget主要分为StatelessWidget（无状态） 和 StatefulWidget（有状态） 两种，StatelessWidget只进行一次创建绘制，生命周期很简单不在谈，StatefulWidget的生命周期方法相对多一些。</p>\n<p>本文主要总结两部分：</p>\n<ul>\n<li>StatefulWidget生命周期（针对Widget）</li>\n<li>监听App生命周期（针对应用）</li>\n</ul>\n<h2 id=\"statefulwidget生命周期\">StatefulWidget生命周期<a title=\"#statefulwidget生命周期\" href=\"#statefulwidget生命周期\"></a></h2>\n<p>StatefulWidget 的生命周期比较复杂，依次为：</p>\n<ul>\n<li>creatState</li>\n<li>initState</li>\n<li>didChangeDependencies</li>\n<li>build</li>\n<li>didUpdateWidget</li>\n<li>deactivate</li>\n<li>dispose</li>\n</ul>\n<p>其他辅助生命周期：</p>\n<ul>\n<li>addPostFrameCallback</li>\n<li>reassemble</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/CDED2B33A48040A8A585C32AAAB6F37F?method=download&amp;shareKey=b09b817bdbc0df723206b181a4da8604\" alt=\"StatefulWidget生命周期\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"creatstate\">creatState<a title=\"#creatstate\" href=\"#creatstate\"></a></h3>\n<p>当要创建新的 StatefulWidget 的时候，会立即执行 createState，也就是StatefulWidget需要绑定一个状态，只执行一次</p>\n<h3 id=\"initstate\">initState<a title=\"#initstate\" href=\"#initstate\"></a></h3>\n<p>initState 是 StatefulWidget 创建完后调用的第一个方法，而且只执行一次，类似于 Android 的 onCreate，此时view并没有渲染，但是这时 StatefulWidget 已经被加载到渲染树里了。</p>\n<p>initState执行时，可以在这个方法里初始化一些数据，或者异步加载一些数据。</p>\n<h3 id=\"didchangedependencies\">didChangeDependencies<a title=\"#didchangedependencies\" href=\"#didchangedependencies\"></a></h3>\n<p>顾名思义：“依赖改变时发生”，Widget所属的父类对该Widget布局约束发生了改变就会调用。</p>\n<ul>\n<li>当 StatefulWidget 第一次创建的时候，didChangeDependencies 方法会在 initState 方法之后立即调用，之后当 StatefulWidget 刷新的时候，就不会调用了。</li>\n<li>StatefulWidget 依赖的 InheritedWidget 发生变化之后，didChangeDependencies 才会调用。</li>\n</ul>\n<p>典型的场景是当系统语言Locale或应用主题改变时，Flutter framework会通知widget调用此回调。</p>\n<h3 id=\"build\">build<a title=\"#build\" href=\"#build\"></a></h3>\n<p>build，主要是返回需要渲染的widget，状态改变时都会触发build执行：</p>\n<ul>\n<li>父类的build执行时</li>\n<li>initState之后</li>\n<li>setState之后</li>\n</ul>\n<h3 id=\"addpostframecallback\">addPostFrameCallback<a title=\"#addpostframecallback\" href=\"#addpostframecallback\"></a></h3>\n<p>addPostFrameCallback 是 StatefulWidge 渲染结束的回调，只会被调用一次，之后 StatefulWidget 需要刷新 UI 也不会被调用。</p>\n<p>addPostFrameCallback 的使用方法是在 initState 里添加回调：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;package:flutter/scheduler.dart&#x27;</span>;</span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.initState();</span><br><span class=\"line\">  SchedulerBinding.instance.addPostFrameCallback((_) =&gt; &#123;&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"reassemble\">reassemble<a title=\"#reassemble\" href=\"#reassemble\"></a></h3>\n<p>在 debug 模式下，每次热重载都会调用该函数，因此在 debug 阶段可以在此期间增加一些 debug 代码，来检查代码问题。</p>\n<h3 id=\"didupdatewidget\">didUpdateWidget<a title=\"#didupdatewidget\" href=\"#didupdatewidget\"></a></h3>\n<p>在widget重新构建时，Flutter framework会调用Widget.canUpdate来检测Widget树中同一位置的新旧节点，然后决定是否需要更新，如果Widget.canUpdate返回true则会调用此回调。</p>\n<h3 id=\"deactivate\">deactivate<a title=\"#deactivate\" href=\"#deactivate\"></a></h3>\n<p>当要将 State 对象从渲染树中移除的时候，就会调用 deactivate 生命周期，这标志着 StatefulWidget 将要销毁，但是有时候 State 不会被销毁，而是重新插入到渲染树种。</p>\n<h3 id=\"dispose\">dispose<a title=\"#dispose\" href=\"#dispose\"></a></h3>\n<p>当 View 不需要再显示，从渲染树中移除的时候，State 就会永久的从渲染树中移除，就会调用 dispose 生命周期，这时候就可以在 dispose 里做一些取消监听、动画的操作，和 initState 是相反的。</p>\n<h2 id=\"监听app生命周期\">监听App生命周期<a title=\"#监听app生命周期\" href=\"#监听app生命周期\"></a></h2>\n<p>app生命周期主要是一些前台后台动作，可以使用WidgetsBindingObserver来监测，方法如下：</p>\n<p>1.在State 的类 mix WidgetsBindingObserver，并重写didChangeAppLifecycleState方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_MyHomePageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">MyHomePage</span>&gt; <span class=\"title\">with</span> <span class=\"title\">WidgetsBindingObserver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> didChangeAppLifecycleState(AppLifecycleState state) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.didChangeAppLifecycleState(state);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state == AppLifecycleState.paused) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// went to Background</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state == AppLifecycleState.resumed) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// came back to Foreground</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.在 State 的 initState 里添加监听：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> initState()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.initState();</span><br><span class=\"line\">    WidgetsBinding.instance.addObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>3.在 State 的 dispose 里移除监听：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> dispose() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// <span class=\"doctag\">TODO:</span> implement dispose</span></span><br><span class=\"line\">  <span class=\"keyword\">super</span>.dispose();</span><br><span class=\"line\">  WidgetsBinding.instance.removeObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AppLifecycleState 有以下几种状态：</p>\n<ul>\n<li>resumed：同Android的onResume</li>\n<li>inactive：同Android的onPause</li>\n<li>paused：同Android的onStop</li>\n<li>suspending：应用挂起</li>\n</ul>\n","prev":{"title":"Flutter开发语言Dart学习","link":"posts/1642687720"},"next":{"title":"Flutter开发必知必会","link":"posts/1642607126"},"plink":"https://blog.ixin.run/posts/1642687671/","toc":[{"id":"前言","title":"前言","index":"1"},{"id":"statefulwidget生命周期","title":"StatefulWidget生命周期","index":"2","children":[{"id":"creatstate","title":"creatState","index":"2.1"},{"id":"initstate","title":"initState","index":"2.2"},{"id":"didchangedependencies","title":"didChangeDependencies","index":"2.3"},{"id":"build","title":"build","index":"2.4"},{"id":"addpostframecallback","title":"addPostFrameCallback","index":"2.5"},{"id":"reassemble","title":"reassemble","index":"2.6"},{"id":"didupdatewidget","title":"didUpdateWidget","index":"2.7"},{"id":"deactivate","title":"deactivate","index":"2.8"},{"id":"dispose","title":"dispose","index":"2.9"}]},{"id":"监听app生命周期","title":"监听App生命周期","index":"3"}],"reward":true,"copyright":{"author":"乂星人","link":"<a href=\"https://blog.ixin.run/posts/1642687671/\" title=\"Flutter生命周期\">https://blog.ixin.run/posts/1642687671/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}